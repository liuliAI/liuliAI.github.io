{
    "version": "https://jsonfeed.org/version/1",
    "title": "liuliAI • All posts by \"多核并行\" tag",
    "description": "",
    "home_page_url": "https://liuliai.github.io",
    "items": [
        {
            "id": "https://liuliai.github.io/2024/03/10/Python%E5%A4%9A%E6%A0%B8%E5%B9%B6%E8%A1%8C%E6%93%8D%E4%BD%9C/",
            "url": "https://liuliai.github.io/2024/03/10/Python%E5%A4%9A%E6%A0%B8%E5%B9%B6%E8%A1%8C%E6%93%8D%E4%BD%9C/",
            "title": "Python多核并行操作",
            "date_published": "2024-03-10T03:59:00.000Z",
            "content_html": "<h2>Python多核并行操作</h2>\n<p>如果你执行的只是很小的程序，可能单核便能满足你的要求。但是如果你要运行很大的数据类型，比如生物信息学，比如图像的预处理等，这些如果单核处理起来会非常废时间，64 核的 CPU 很多核都没有利用起来。这个时候就需要使用 CPU 的多核并行技术来提升效率。 使用 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>h</mi><mi>t</mi><mi>o</mi><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">htop</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">h</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">p</span></span></span></span> 命令就可以看到服务器的核运行情况。</p>\n<p>Python 默认的多进程、多线程库 multiprocessing and threading 很好用，如果你用的是 Python 默认的解析器 (CPython)，那么你只能放弃使用 threading 库，因为 GIL 的存在，多线程会让你的 Python 程序跑的比单线程还慢。当然，如果你使用的是 JPython 解析器，或者说你的解析器没有 GIL 对你程序的影响，那么你可以尝试去使用多线程。关于 GIL 的更多信息可在此处查看<a href=\"https://www.realvnc.com/en/connect/download/viewer/windows/\" style=\"color: LimeGreen;\">Python 的 GIL 是什么鬼，多线程性能究竟如何</a>（最近的 Python 3.12 新特性可以为每个子解释器单独创建一个 GIL，这样就可以让 Python 充分利用多核的性能，详细信息可见<a href=\"https://cloud.tencent.com/developer/article/2219746\" style=\"color: LimeGreen;\">Python-3.12 告别 GIL 锁 &amp; 性能原地飞升！</a>和<a href=\"https://www.cnblogs.com/Chang-LeHung/p/17747159.html\" style=\"color: LimeGreen;\">Python3.12 新特性 ——GIL 重大突破！</a>）</p>\n<p>这里只讲述 Python 库 multiprocessing。<br>\n讲怎么使用之前，需要先明确一个概念。由于 multiprocessing 是一个创建多进程的库，那么如果你要调用的函数在同一个.py 文件下运行的话是不可以的，你分配给进程的函数需要通过 import 导入。例如：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">import multiprocessing\ndef f(x):\n    return x ** 2\npool &#x3D; multiprocessing.Pool(processes&#x3D;5)\ny &#x3D; range(5)\nprint(pool.map(f, y))<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>上述程序是不能跑的，因为要调用的函数和 pool 的创建在同一个进程中。正确做法应该是：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">import multiprocessing\ndef f(x):\n    return x ** 2\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    pool &#x3D; multiprocessing.Pool(processes&#x3D;5)\n    y &#x3D; range(5)\n    print(pool.map(f, y))<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>或者：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">import multiprocessing\nfrom fx import f\npool &#x3D; multiprocessing.Pool(processes&#x3D;5)\ny &#x3D; range(5)\nprint(pool.map(f, y))   # [0, 1, 4, 9, 16]<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>这样做的目的是为了进程安全，<a href=\"https://docs.python.org/3/library/multiprocessing.html#multiprocessing-programming\" style=\"color: LimeGreen;\">更多信息</a><br>\n那么，明确了这个问题之后，开始讲一下 multiprocessing 如何使用。</p>\n<h4 id=\"pool对象\"><a class=\"markdownIt-Anchor\" href=\"#pool对象\">#</a> Pool 对象</h4>\n<p>Python 提供了非常简单的 Pool 对象来实现进程池。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">pool &#x3D; multiprocessing.Pool(processes&#x3D;5)    # 创建进程池，并且容纳上限为5个进程。<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>而 pool.map (f, y) 是对可迭代对象 y 的每个对象均使用一次 f 函数，并返回每次执行后的数据列表。 与 pool.map () 相似的还有 pool.imap () 和 pool.imap_unordered ()，不同的是后面两个返回的都是迭代器，而最后一个和名字一样，返回的数据是无序的。</p>\n<h4 id=\"process对象\"><a class=\"markdownIt-Anchor\" href=\"#process对象\">#</a> Process 对象</h4>\n<p>具体例子</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">import os\nimport multiprocessing\n\n# Main\nprint(&#39;Main:&#39;, os.getpid())\n\n\n# worker function\ndef worker(sign, lock):\n    lock.acquire()\n    print(sign, os.getpid())\n    lock.release()\n\n\n# Multi-process\nrecord &#x3D; []\nlock &#x3D; multiprocessing.Lock()\n\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    for i in range(5):\n        process &#x3D; multiprocessing.Process(target&#x3D;worker, args&#x3D;(&#39;process&#39;, lock))    # 创建进程对象，把和参数(&#39;process&#39;, lock)赋给函数worker并且让进程执行worker\n        process.start() # 启动进程\n        record.append(process)\n\n    for process in record:\n        process.join()  # 这里可以填入参数，效果为阻塞多少秒，如果为None那么就是终止进程。<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h5 id=\"output\"><a class=\"markdownIt-Anchor\" href=\"#output\">#</a> output:</h5>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Main: 96217\nprocess 96300\nprocess 96301\nprocess 96302\nprocess 96303\nprocess 96304<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>这是创建进程对象并且让他自己打印自己的 PID，为了防止输出的数据是乱序的，这里加了一把进程锁 lock =multiprocessing.Lock ()，只有拿到锁的进程才能够打印自己的 PID。</p>\n<h4 id=\"pipe和queue\"><a class=\"markdownIt-Anchor\" href=\"#pipe和queue\">#</a> Pipe 和 Queue</h4>\n<p>和名字一样，分别对应操作系统中的管道和消息队列。看两个例子：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">import multiprocessing as mul\n\n\ndef proc1(pipe):\n    pipe.send(&#39;hello&#39;)\n    print(&#39;proc1 rec:&#39;, pipe.recv())\n\n\ndef proc2(pipe):\n    print(&#39;proc2 rec:&#39;, pipe.recv())\n    pipe.send(&#39;hello, too&#39;)\n\n\n# Build a pipe\npipe &#x3D; mul.Pipe()\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    # Pass an end of the pipe to process 1\n    p1 &#x3D; mul.Process(target&#x3D;proc1, args&#x3D;(pipe[0],))\n    # Pass the other end of the pipe to process 2\n    p2 &#x3D; mul.Process(target&#x3D;proc2, args&#x3D;(pipe[1],))\n    p1.start()\n    p2.start()\n    p1.join()\n    p2.join()<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h5 id=\"output-2\"><a class=\"markdownIt-Anchor\" href=\"#output-2\">#</a> output:</h5>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">proc2 rec: hello\nproc1 rec: hello, too<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>Pipe 对象建立的时候，返回一个含有两个元素的表，每个元素代表 Pipe 的一端 (Connection 对象)。我们对 Pipe 的某一端调用 send () 方法来传送对象，在另一端使用 recv () 来接收。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">import os\nimport multiprocessing\nimport time\n\ndef inputQ(queue):\n    info &#x3D; str(os.getpid()) + &#39;(put):&#39; + str(time.time())\n    queue.put(info)\n\ndef outputQ(queue,lock):\n    info &#x3D; queue.get()\n    lock.acquire()\n    print (str(os.getpid()) + &#39; get: &#39; + info)\n    lock.release()\n    \nrecord1 &#x3D; []   # store input processes\nrecord2 &#x3D; []   # store output processes\nlock  &#x3D; multiprocessing.Lock()    # To prevent messy print\nqueue &#x3D; multiprocessing.Queue(3)\n\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    # input processes\n    for i in range(10):\n        process &#x3D; multiprocessing.Process(target&#x3D;inputQ,args&#x3D;(queue,))\n        process.start()\n        record1.append(process)\n    \n    # output processes\n    for i in range(10):\n        process &#x3D; multiprocessing.Process(target&#x3D;outputQ,args&#x3D;(queue,lock))\n        process.start()\n        record2.append(process)\n    \n    for p in record1:\n        p.join()\n    \n    queue.close()  # No more object will come, close the queue\n    \n    for p in record2:\n        p.join()<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>一些进程使用 put () 在 Queue 中放入字符串，这个字符串中包含 PID 和时间。另一些进程从 Queue 中取出，并打印自己的 PID 以及 get () 的字符串。</p>\n",
            "tags": [
                "Python",
                "多核并行"
            ]
        }
    ]
}