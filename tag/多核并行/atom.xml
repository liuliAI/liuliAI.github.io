<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://liuliai.github.io</id>
    <title>liuliAI • Posts by &#34;多核并行&#34; tag</title>
    <link href="https://liuliai.github.io" />
    <updated>2024-03-10T03:59:00.000Z</updated>
    <category term="RWKV" />
    <category term="Mamba" />
    <category term="KAN" />
    <category term="TTT" />
    <category term="线性架构" />
    <category term="CoT" />
    <category term="多模态" />
    <category term="大模型" />
    <category term="长期记忆" />
    <category term="RAG" />
    <category term="Linux" />
    <category term="教程" />
    <category term="Embodied AI" />
    <category term="VLN" />
    <category term="Python" />
    <category term="多核并行" />
    <category term="四元数" />
    <category term="服务器" />
    <category term="概率机器人" />
    <category term="SALM" />
    <category term="数学" />
    <category term="矩阵分析" />
    <category term="数值分析" />
    <category term="数学建模" />
    <category term="电工杯" />
    <category term="遗传算法" />
    <category term="状压DP" />
    <category term="TSP旅行商" />
    <entry>
        <id>https://liuliai.github.io/2024/03/10/Python%E5%A4%9A%E6%A0%B8%E5%B9%B6%E8%A1%8C%E6%93%8D%E4%BD%9C/</id>
        <title>Python多核并行操作</title>
        <link rel="alternate" href="https://liuliai.github.io/2024/03/10/Python%E5%A4%9A%E6%A0%B8%E5%B9%B6%E8%A1%8C%E6%93%8D%E4%BD%9C/"/>
        <content type="html">&lt;h2&gt;Python多核并行操作&lt;/h2&gt;
&lt;p&gt;如果你执行的只是很小的程序，可能单核便能满足你的要求。但是如果你要运行很大的数据类型，比如生物信息学，比如图像的预处理等，这些如果单核处理起来会非常废时间，64 核的 CPU 很多核都没有利用起来。这个时候就需要使用 CPU 的多核并行技术来提升效率。 使用 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;htop&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8888799999999999em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;p&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 命令就可以看到服务器的核运行情况。&lt;/p&gt;
&lt;p&gt;Python 默认的多进程、多线程库 multiprocessing and threading 很好用，如果你用的是 Python 默认的解析器 (CPython)，那么你只能放弃使用 threading 库，因为 GIL 的存在，多线程会让你的 Python 程序跑的比单线程还慢。当然，如果你使用的是 JPython 解析器，或者说你的解析器没有 GIL 对你程序的影响，那么你可以尝试去使用多线程。关于 GIL 的更多信息可在此处查看&lt;a href=&#34;https://www.realvnc.com/en/connect/download/viewer/windows/&#34; style=&#34;color: LimeGreen;&#34;&gt;Python 的 GIL 是什么鬼，多线程性能究竟如何&lt;/a&gt;（最近的 Python 3.12 新特性可以为每个子解释器单独创建一个 GIL，这样就可以让 Python 充分利用多核的性能，详细信息可见&lt;a href=&#34;https://cloud.tencent.com/developer/article/2219746&#34; style=&#34;color: LimeGreen;&#34;&gt;Python-3.12 告别 GIL 锁 &amp;amp; 性能原地飞升！&lt;/a&gt;和&lt;a href=&#34;https://www.cnblogs.com/Chang-LeHung/p/17747159.html&#34; style=&#34;color: LimeGreen;&#34;&gt;Python3.12 新特性 ——GIL 重大突破！&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;这里只讲述 Python 库 multiprocessing。&lt;br&gt;
讲怎么使用之前，需要先明确一个概念。由于 multiprocessing 是一个创建多进程的库，那么如果你要调用的函数在同一个.py 文件下运行的话是不可以的，你分配给进程的函数需要通过 import 导入。例如：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-none&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;import multiprocessing
def f(x):
    return x ** 2
pool &amp;#x3D; multiprocessing.Pool(processes&amp;#x3D;5)
y &amp;#x3D; range(5)
print(pool.map(f, y))&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述程序是不能跑的，因为要调用的函数和 pool 的创建在同一个进程中。正确做法应该是：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-none&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;import multiprocessing
def f(x):
    return x ** 2
if __name__ &amp;#x3D;&amp;#x3D; &amp;#39;__main__&amp;#39;:
    pool &amp;#x3D; multiprocessing.Pool(processes&amp;#x3D;5)
    y &amp;#x3D; range(5)
    print(pool.map(f, y))&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或者：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-none&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;import multiprocessing
from fx import f
pool &amp;#x3D; multiprocessing.Pool(processes&amp;#x3D;5)
y &amp;#x3D; range(5)
print(pool.map(f, y))   # [0, 1, 4, 9, 16]&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样做的目的是为了进程安全，&lt;a href=&#34;https://docs.python.org/3/library/multiprocessing.html#multiprocessing-programming&#34; style=&#34;color: LimeGreen;&#34;&gt;更多信息&lt;/a&gt;&lt;br&gt;
那么，明确了这个问题之后，开始讲一下 multiprocessing 如何使用。&lt;/p&gt;
&lt;h4 id=&#34;pool对象&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#pool对象&#34;&gt;#&lt;/a&gt; Pool 对象&lt;/h4&gt;
&lt;p&gt;Python 提供了非常简单的 Pool 对象来实现进程池。&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-none&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;pool &amp;#x3D; multiprocessing.Pool(processes&amp;#x3D;5)    # 创建进程池，并且容纳上限为5个进程。&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;而 pool.map (f, y) 是对可迭代对象 y 的每个对象均使用一次 f 函数，并返回每次执行后的数据列表。 与 pool.map () 相似的还有 pool.imap () 和 pool.imap_unordered ()，不同的是后面两个返回的都是迭代器，而最后一个和名字一样，返回的数据是无序的。&lt;/p&gt;
&lt;h4 id=&#34;process对象&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#process对象&#34;&gt;#&lt;/a&gt; Process 对象&lt;/h4&gt;
&lt;p&gt;具体例子&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-none&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;import os
import multiprocessing

# Main
print(&amp;#39;Main:&amp;#39;, os.getpid())


# worker function
def worker(sign, lock):
    lock.acquire()
    print(sign, os.getpid())
    lock.release()


# Multi-process
record &amp;#x3D; []
lock &amp;#x3D; multiprocessing.Lock()

if __name__ &amp;#x3D;&amp;#x3D; &amp;#39;__main__&amp;#39;:
    for i in range(5):
        process &amp;#x3D; multiprocessing.Process(target&amp;#x3D;worker, args&amp;#x3D;(&amp;#39;process&amp;#39;, lock))    # 创建进程对象，把和参数(&amp;#39;process&amp;#39;, lock)赋给函数worker并且让进程执行worker
        process.start() # 启动进程
        record.append(process)

    for process in record:
        process.join()  # 这里可以填入参数，效果为阻塞多少秒，如果为None那么就是终止进程。&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;output&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#output&#34;&gt;#&lt;/a&gt; output:&lt;/h5&gt;
&lt;pre class=&#34;line-numbers language-none&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;Main: 96217
process 96300
process 96301
process 96302
process 96303
process 96304&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这是创建进程对象并且让他自己打印自己的 PID，为了防止输出的数据是乱序的，这里加了一把进程锁 lock =multiprocessing.Lock ()，只有拿到锁的进程才能够打印自己的 PID。&lt;/p&gt;
&lt;h4 id=&#34;pipe和queue&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#pipe和queue&#34;&gt;#&lt;/a&gt; Pipe 和 Queue&lt;/h4&gt;
&lt;p&gt;和名字一样，分别对应操作系统中的管道和消息队列。看两个例子：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-none&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;import multiprocessing as mul


def proc1(pipe):
    pipe.send(&amp;#39;hello&amp;#39;)
    print(&amp;#39;proc1 rec:&amp;#39;, pipe.recv())


def proc2(pipe):
    print(&amp;#39;proc2 rec:&amp;#39;, pipe.recv())
    pipe.send(&amp;#39;hello, too&amp;#39;)


# Build a pipe
pipe &amp;#x3D; mul.Pipe()
if __name__ &amp;#x3D;&amp;#x3D; &amp;#39;__main__&amp;#39;:
    # Pass an end of the pipe to process 1
    p1 &amp;#x3D; mul.Process(target&amp;#x3D;proc1, args&amp;#x3D;(pipe[0],))
    # Pass the other end of the pipe to process 2
    p2 &amp;#x3D; mul.Process(target&amp;#x3D;proc2, args&amp;#x3D;(pipe[1],))
    p1.start()
    p2.start()
    p1.join()
    p2.join()&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;output-2&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#output-2&#34;&gt;#&lt;/a&gt; output:&lt;/h5&gt;
&lt;pre class=&#34;line-numbers language-none&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;proc2 rec: hello
proc1 rec: hello, too&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Pipe 对象建立的时候，返回一个含有两个元素的表，每个元素代表 Pipe 的一端 (Connection 对象)。我们对 Pipe 的某一端调用 send () 方法来传送对象，在另一端使用 recv () 来接收。&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-none&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;import os
import multiprocessing
import time

def inputQ(queue):
    info &amp;#x3D; str(os.getpid()) + &amp;#39;(put):&amp;#39; + str(time.time())
    queue.put(info)

def outputQ(queue,lock):
    info &amp;#x3D; queue.get()
    lock.acquire()
    print (str(os.getpid()) + &amp;#39; get: &amp;#39; + info)
    lock.release()
    
record1 &amp;#x3D; []   # store input processes
record2 &amp;#x3D; []   # store output processes
lock  &amp;#x3D; multiprocessing.Lock()    # To prevent messy print
queue &amp;#x3D; multiprocessing.Queue(3)

if __name__ &amp;#x3D;&amp;#x3D; &amp;#39;__main__&amp;#39;:
    # input processes
    for i in range(10):
        process &amp;#x3D; multiprocessing.Process(target&amp;#x3D;inputQ,args&amp;#x3D;(queue,))
        process.start()
        record1.append(process)
    
    # output processes
    for i in range(10):
        process &amp;#x3D; multiprocessing.Process(target&amp;#x3D;outputQ,args&amp;#x3D;(queue,lock))
        process.start()
        record2.append(process)
    
    for p in record1:
        p.join()
    
    queue.close()  # No more object will come, close the queue
    
    for p in record2:
        p.join()&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一些进程使用 put () 在 Queue 中放入字符串，这个字符串中包含 PID 和时间。另一些进程从 Queue 中取出，并打印自己的 PID 以及 get () 的字符串。&lt;/p&gt;
</content>
        <category term="Python" />
        <category term="多核并行" />
        <updated>2024-03-10T03:59:00.000Z</updated>
    </entry>
</feed>
