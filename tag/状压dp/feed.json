{
    "version": "https://jsonfeed.org/version/1",
    "title": "liuliAI • All posts by \"状压dp\" tag",
    "description": "",
    "home_page_url": "https://liuliai.github.io",
    "items": [
        {
            "id": "https://liuliai.github.io/2023/12/09/%E7%AC%AC%E5%8D%81%E5%9B%9B%E5%B1%8A%E5%85%A8%E5%9B%BD%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%94%B5%E5%B7%A5%E6%9D%AF%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E7%AB%9E%E8%B5%9B/",
            "url": "https://liuliai.github.io/2023/12/09/%E7%AC%AC%E5%8D%81%E5%9B%9B%E5%B1%8A%E5%85%A8%E5%9B%BD%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%94%B5%E5%B7%A5%E6%9D%AF%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E7%AB%9E%E8%B5%9B/",
            "title": "第十四届全国大学生电工杯数学建模竞赛",
            "date_published": "2023-12-09T03:59:00.000Z",
            "content_html": "<p>没有哪次竞赛比这次更累了，建模、编程、论文三合一，加班加点的通宵，比完直接躺了两天。当然，对于自己各方面的提升也是巨大的，最后也是不负众望，和室友、班长共同努力下取得了一等奖。<br>\n<img src=\"/image/dgb.png\" alt=\"\"></p>\n<p>B 题如下<br>\n<img src=\"/image/dgb2.jpg\" alt=\"\"></p>\n<p>第一问很简单是可重复访问的 TSP 问题，有多种方法，例如多次 Dijkstra + 剪枝优化，暴力枚举 + 剪枝优化（<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">!</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n!)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">!</span><span class=\"mclose\">)</span></span></span></span>），遗传算法，状压 DP（状态压缩动态规划，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>⋅</mo><msup><mn>2</mn><mi>n</mi></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^{2}\\cdot 2^{n})</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>）等等。由于数量级问题，遗传算法大概 2 分钟，其他算法不推荐。<br>\n状压 DP 代码如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">import sys\n\ndef tsp(dp, mask, pos, dist, n):\n    # 如果所有城市都访问过，返回当前位置到起点的距离\n    if mask &#x3D;&#x3D; (1 &lt;&lt; n) - 1:\n        return dist[pos][0]\n    \n    # 如果这个状态已经计算过，直接返回结果\n    if dp[mask][pos] !&#x3D; -1:\n        return dp[mask][pos]\n    \n    ans &#x3D; sys.maxsize\n    # 尝试访问每个城市\n    for i in range(n):\n        # 如果这个城市还没有被访问过\n        if (mask &amp; (1 &lt;&lt; i)) &#x3D;&#x3D; 0:\n            # 计算通过这个城市到下一个城市的新路径长度\n            newAns &#x3D; dist[pos][i] + tsp(dp, mask | (1 &lt;&lt; i), i, dist, n)\n            ans &#x3D; min(ans, newAns)\n    \n    # 记录并返回当前状态的最短路径长度\n    dp[mask][pos] &#x3D; ans\n    return ans<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>第二问复杂的多，改进遗传算法，增加一条代表无人机路径的染色体并且由于无人机载重限制，同一地点可能需要重复飞行，将配送地点当日物资需求量利用阶跃函数和取整函数进行分界设置为无人机染色体中该地点基因的权重，由此控制变异之后该地点基因出现概率。得出完成一次整体配送的最优方案时间。</p>\n<p>第三问延续第二问进行二次改进，设置配送车辆染色体 9 号基因的权重为较大值，即可使配送车辆染色体以较大的变异概率出现 9 号基因，即中途返回出发地，得出完成一次整体配送最优方案时间。</p>\n<p>第四问由于计划设置两个应急物资集中地点，因此使用 K-median 聚类方法进行聚类，同时，将各地点当日物资需求量作为聚类点集权重，聚类得出两个应急物资中心点为地点 5 和地点 25，且将图分为两部分，之后使用问题三中改进的遗传算法计算两次，分别得出两个应急物资点完成一次整体配送的最优方案。</p>\n",
            "tags": [
                "数学建模",
                "电工杯",
                "遗传算法",
                "状压DP",
                "TSP旅行商"
            ]
        }
    ]
}