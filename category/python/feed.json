{
    "version": "https://jsonfeed.org/version/1",
    "title": "liuliAI • All posts by \"python\" category",
    "description": "",
    "home_page_url": "https://liuliai.github.io",
    "items": [
        {
            "id": "https://liuliai.github.io/2024/03/10/Python%E5%A4%9A%E6%A0%B8%E5%B9%B6%E8%A1%8C%E6%93%8D%E4%BD%9C/",
            "url": "https://liuliai.github.io/2024/03/10/Python%E5%A4%9A%E6%A0%B8%E5%B9%B6%E8%A1%8C%E6%93%8D%E4%BD%9C/",
            "title": "Python多核并行操作",
            "date_published": "2024-03-10T03:59:00.000Z",
            "content_html": "<h2>Python多核并行操作</h2>\n<p>如果你执行的只是很小的程序，可能单核便能满足你的要求。但是如果你要运行很大的数据类型，比如生物信息学，比如图像的预处理等，这些如果单核处理起来会非常废时间，64 核的 CPU 很多核都没有利用起来。这个时候就需要使用 CPU 的多核并行技术来提升效率。 使用 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>h</mi><mi>t</mi><mi>o</mi><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">htop</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">h</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">p</span></span></span></span> 命令就可以看到服务器的核运行情况。</p>\n<p>Python 默认的多进程、多线程库 multiprocessing and threading 很好用，如果你用的是 Python 默认的解析器 (CPython)，那么你只能放弃使用 threading 库，因为 GIL 的存在，多线程会让你的 Python 程序跑的比单线程还慢。当然，如果你使用的是 JPython 解析器，或者说你的解析器没有 GIL 对你程序的影响，那么你可以尝试去使用多线程。关于 GIL 的更多信息可在此处查看<a href=\"https://www.realvnc.com/en/connect/download/viewer/windows/\" style=\"color: LimeGreen;\">Python 的 GIL 是什么鬼，多线程性能究竟如何</a>（最近的 Python 3.12 新特性可以为每个子解释器单独创建一个 GIL，这样就可以让 Python 充分利用多核的性能，详细信息可见<a href=\"https://cloud.tencent.com/developer/article/2219746\" style=\"color: LimeGreen;\">Python-3.12 告别 GIL 锁 &amp; 性能原地飞升！</a>和<a href=\"https://www.cnblogs.com/Chang-LeHung/p/17747159.html\" style=\"color: LimeGreen;\">Python3.12 新特性 ——GIL 重大突破！</a>）</p>\n<p>这里只讲述 Python 库 multiprocessing。<br>\n讲怎么使用之前，需要先明确一个概念。由于 multiprocessing 是一个创建多进程的库，那么如果你要调用的函数在同一个.py 文件下运行的话是不可以的，你分配给进程的函数需要通过 import 导入。例如：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">import multiprocessing\ndef f(x):\n    return x ** 2\npool &#x3D; multiprocessing.Pool(processes&#x3D;5)\ny &#x3D; range(5)\nprint(pool.map(f, y))<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>上述程序是不能跑的，因为要调用的函数和 pool 的创建在同一个进程中。正确做法应该是：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">import multiprocessing\ndef f(x):\n    return x ** 2\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    pool &#x3D; multiprocessing.Pool(processes&#x3D;5)\n    y &#x3D; range(5)\n    print(pool.map(f, y))<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>或者：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">import multiprocessing\nfrom fx import f\npool &#x3D; multiprocessing.Pool(processes&#x3D;5)\ny &#x3D; range(5)\nprint(pool.map(f, y))   # [0, 1, 4, 9, 16]<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>这样做的目的是为了进程安全，<a href=\"https://docs.python.org/3/library/multiprocessing.html#multiprocessing-programming\" style=\"color: LimeGreen;\">更多信息</a><br>\n那么，明确了这个问题之后，开始讲一下 multiprocessing 如何使用。</p>\n<h4 id=\"pool对象\"><a class=\"markdownIt-Anchor\" href=\"#pool对象\">#</a> Pool 对象</h4>\n<p>Python 提供了非常简单的 Pool 对象来实现进程池。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">pool &#x3D; multiprocessing.Pool(processes&#x3D;5)    # 创建进程池，并且容纳上限为5个进程。<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>而 pool.map (f, y) 是对可迭代对象 y 的每个对象均使用一次 f 函数，并返回每次执行后的数据列表。 与 pool.map () 相似的还有 pool.imap () 和 pool.imap_unordered ()，不同的是后面两个返回的都是迭代器，而最后一个和名字一样，返回的数据是无序的。</p>\n<h4 id=\"process对象\"><a class=\"markdownIt-Anchor\" href=\"#process对象\">#</a> Process 对象</h4>\n<p>具体例子</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">import os\nimport multiprocessing\n\n# Main\nprint(&#39;Main:&#39;, os.getpid())\n\n\n# worker function\ndef worker(sign, lock):\n    lock.acquire()\n    print(sign, os.getpid())\n    lock.release()\n\n\n# Multi-process\nrecord &#x3D; []\nlock &#x3D; multiprocessing.Lock()\n\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    for i in range(5):\n        process &#x3D; multiprocessing.Process(target&#x3D;worker, args&#x3D;(&#39;process&#39;, lock))    # 创建进程对象，把和参数(&#39;process&#39;, lock)赋给函数worker并且让进程执行worker\n        process.start() # 启动进程\n        record.append(process)\n\n    for process in record:\n        process.join()  # 这里可以填入参数，效果为阻塞多少秒，如果为None那么就是终止进程。<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h5 id=\"output\"><a class=\"markdownIt-Anchor\" href=\"#output\">#</a> output:</h5>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Main: 96217\nprocess 96300\nprocess 96301\nprocess 96302\nprocess 96303\nprocess 96304<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>这是创建进程对象并且让他自己打印自己的 PID，为了防止输出的数据是乱序的，这里加了一把进程锁 lock =multiprocessing.Lock ()，只有拿到锁的进程才能够打印自己的 PID。</p>\n<h4 id=\"pipe和queue\"><a class=\"markdownIt-Anchor\" href=\"#pipe和queue\">#</a> Pipe 和 Queue</h4>\n<p>和名字一样，分别对应操作系统中的管道和消息队列。看两个例子：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">import multiprocessing as mul\n\n\ndef proc1(pipe):\n    pipe.send(&#39;hello&#39;)\n    print(&#39;proc1 rec:&#39;, pipe.recv())\n\n\ndef proc2(pipe):\n    print(&#39;proc2 rec:&#39;, pipe.recv())\n    pipe.send(&#39;hello, too&#39;)\n\n\n# Build a pipe\npipe &#x3D; mul.Pipe()\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    # Pass an end of the pipe to process 1\n    p1 &#x3D; mul.Process(target&#x3D;proc1, args&#x3D;(pipe[0],))\n    # Pass the other end of the pipe to process 2\n    p2 &#x3D; mul.Process(target&#x3D;proc2, args&#x3D;(pipe[1],))\n    p1.start()\n    p2.start()\n    p1.join()\n    p2.join()<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h5 id=\"output-2\"><a class=\"markdownIt-Anchor\" href=\"#output-2\">#</a> output:</h5>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">proc2 rec: hello\nproc1 rec: hello, too<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>Pipe 对象建立的时候，返回一个含有两个元素的表，每个元素代表 Pipe 的一端 (Connection 对象)。我们对 Pipe 的某一端调用 send () 方法来传送对象，在另一端使用 recv () 来接收。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">import os\nimport multiprocessing\nimport time\n\ndef inputQ(queue):\n    info &#x3D; str(os.getpid()) + &#39;(put):&#39; + str(time.time())\n    queue.put(info)\n\ndef outputQ(queue,lock):\n    info &#x3D; queue.get()\n    lock.acquire()\n    print (str(os.getpid()) + &#39; get: &#39; + info)\n    lock.release()\n    \nrecord1 &#x3D; []   # store input processes\nrecord2 &#x3D; []   # store output processes\nlock  &#x3D; multiprocessing.Lock()    # To prevent messy print\nqueue &#x3D; multiprocessing.Queue(3)\n\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    # input processes\n    for i in range(10):\n        process &#x3D; multiprocessing.Process(target&#x3D;inputQ,args&#x3D;(queue,))\n        process.start()\n        record1.append(process)\n    \n    # output processes\n    for i in range(10):\n        process &#x3D; multiprocessing.Process(target&#x3D;outputQ,args&#x3D;(queue,lock))\n        process.start()\n        record2.append(process)\n    \n    for p in record1:\n        p.join()\n    \n    queue.close()  # No more object will come, close the queue\n    \n    for p in record2:\n        p.join()<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>一些进程使用 put () 在 Queue 中放入字符串，这个字符串中包含 PID 和时间。另一些进程从 Queue 中取出，并打印自己的 PID 以及 get () 的字符串。</p>\n",
            "tags": [
                "Python",
                "多核并行"
            ]
        },
        {
            "id": "https://liuliai.github.io/2023/06/12/%E5%9C%A8%20Python%20%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/",
            "url": "https://liuliai.github.io/2023/06/12/%E5%9C%A8%20Python%20%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/",
            "title": "Python 中的正则表达式",
            "date_published": "2023-06-12T03:59:00.000Z",
            "content_html": "<h2>Python 中的正则表达式</h2>\n<p>每当你遇到文本处理问题时，正则表达式（regex）不可或缺（在算法题目中也会出现）。</p>\n<h3 id=\"验证电子邮件地址\"><a class=\"markdownIt-Anchor\" href=\"#验证电子邮件地址\">#</a> 验证电子邮件地址</h3>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">import re\ndef val_email(email):\n    pattern &#x3D; r&quot;^[a-zA-Z0-9]+@[a-zA-Z0-9]+\\.[a-zA-Z]&#123;2,&#125;$&quot;\n    if re.match(pattern, email):\n        print(&quot;合法的邮件地址:)&quot;)\n    else:\n        print(&quot;无效的邮件地址!!&quot;)\n\nval_email(email&#x3D;&quot;elon@example.com&quot;)# 合法的邮件地址\n\nval_email(email&#x3D;&quot;elonexample.com&quot;)# 无效的邮件地址!!\n\nval_email(email&#x3D;&quot;elon@example.c&quot;)# 无效的邮件地址!!<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>在这个例子中，我们使用 Python 中的 re 模块来编译一个匹配有效电子邮件格式的正则表达式模式。然后，我们使用它的 match () 函数来检查 email 变量是否与模式匹配。</p>\n<p>在模式中，有几个关键点：</p>\n<ul>\n<li>我们使用 [] 表示一个范围。例如，[a-zA-Z0-9] 可以匹配 0 到 9 之间的数字、A 到 Z 之间的字母或 a 到 z 之间的字母。</li>\n<li>^ 表示行的开头。在我们的例子中，我们使用它来确保文本必须以 [a-zA-Z0-9] 开始。</li>\n<li>$ 表示行的结尾。</li>\n<li>\\ 用于转义特殊字符（允许我们匹配像 ‘.’ 这样的字符）。</li>\n<li>{n,m} 语法是用来匹配 n-m 个先前的正则表达式。我们使用了 {2,}，这意味着前面的部分 [a-zA-Z] 应该至少重复 2 次。这就是为什么 “elon@example.c” 被识别为无效的电子邮件地址。</li>\n<li>. 表示匹配前面的正则表达式至少 1 次。例如，ab+ 将匹配 a 后面的任何非零数量的 b。</li>\n</ul>\n<h3 id=\"从字符串中提取数字\"><a class=\"markdownIt-Anchor\" href=\"#从字符串中提取数字\">#</a> 从字符串中提取数字</h3>\n<p>要从长文本中找到一些特殊字符，最直接的想法是使用 for 循环遍历所有字符并找到所需的内容。</p>\n<p>但是，没有必要使用任何循环。正则表达式就是为了作为过滤器而生的。（时间复杂度更低，更快！！）</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">import re\n\ndef extract_numbers(text):\n    pattern &#x3D; r&quot;\\d+&quot;\n    return re.findall(pattern, text)\n\nprint(extract_numbers(&quot;先将键盘1上的三4行字母5进行6打表100000000。&quot;))\n# [&#39;1456100000000&#39;]<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>re.findall () 函数接收一个正则表达式和一个文本，可以方便地帮助我们找到所有我们需要的字符。</p>\n<p>其中 \\d 用于在正则表达式中匹配数字。</p>\n<h3 id=\"验证有效电话号码\"><a class=\"markdownIt-Anchor\" href=\"#验证有效电话号码\">#</a> 验证有效电话号码</h3>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">import re\n\ndef is_valid_phone_number(phone_number):\n    pattern &#x3D; r&quot;^\\d&#123;3&#125;-\\d&#123;3&#125;-\\d&#123;4&#125;$&quot;\n    return bool(re.match(pattern, phone_number))\n\nprint(is_valid_phone_number(&quot;123-456-7890&quot;))  # True\nprint(is_valid_phone_number(&quot;1234567890&quot;))  # False<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"将文本分割成单词\"><a class=\"markdownIt-Anchor\" href=\"#将文本分割成单词\">#</a> 将文本分割成单词</h3>\n<p>将长文本分割成单独的单词是日常编程中的另一个常见需求。借助 re 模块的 split () 函数，我们可以轻松完成此任务：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">re.split(r&#39;\\s+&#39;, &#39;a b   c&#39;)\n# [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]\n\nre.split(r&#39;[\\s\\,]+&#39;, &#39;a,b, c  d&#39;)\n# [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]\n\nre.split(r&#39;[\\s\\,\\;]+&#39;, &#39;a,b;; c  d&#39;)\n[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"使用正则表达式查找和替换文本\"><a class=\"markdownIt-Anchor\" href=\"#使用正则表达式查找和替换文本\">#</a> 使用正则表达式查找和替换文本</h3>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">import re\n\ntext &#x3D; &quot;linuxmi is an full-stack software engineer.&quot;\npattern &#x3D; r&quot;[a-e]&quot;\nreplacement &#x3D; &quot;*&quot;\n\nnew_text &#x3D; re.sub(pattern, replacement, text)\nprint(new_text)  \n#linuxmi is *n full-st**k softw*r* *ngin**r.<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n",
            "tags": [
                "Python"
            ]
        },
        {
            "id": "https://liuliai.github.io/2023/05/16/%E7%90%86%E8%A7%A3%20Python%20%E4%B8%AD%E7%9A%84%E6%B5%85%E5%A4%8D%E5%88%B6%E5%92%8C%E6%B7%B1%E5%A4%8D%E5%88%B6/",
            "url": "https://liuliai.github.io/2023/05/16/%E7%90%86%E8%A7%A3%20Python%20%E4%B8%AD%E7%9A%84%E6%B5%85%E5%A4%8D%E5%88%B6%E5%92%8C%E6%B7%B1%E5%A4%8D%E5%88%B6/",
            "title": "理解 Python 中的浅复制和深复制",
            "date_published": "2023-05-16T03:59:00.000Z",
            "content_html": "<h2>理解 Python 中的浅复制和深复制\n</h2>\nPython 提供了多种有效的方法来管理数据。在处理嵌套列表、字典或自定义对象等数据结构时，理解浅复制和深复制的概念是至关重要的。\n<p>在 Python 中，浅拷贝和深拷贝是两种不同的拷贝方式。浅拷贝只复制引用，不复制内部对象，而深拷贝则完全复制整个对象，包括其内部的子对象。尤其是在算法中，可能需要用到拷贝的概念来解决问题，如列表、字符串等数据结构（初学者包括我会犯的错， <code>a=[1,2,3,4]</code> ，然后又使用 <code>b=a</code> ，然后在 b 上修改列表，导致 a 也发生变化）</p>\n<p>浅拷贝在 Python 中可以通过几种方式实现，如使用 copy 模块的 copy () 函数，切片操作 [:]，以及字典和集合的拷贝方法.copy ()。深拷贝则可以通过 copy 模块的 deepcopy () 函数来实现。在选择拷贝方式时，重要的是理解对象的结构和需求，以确保拷贝行为符合预期。</p>\n<p>使用浅复制<br>\n浅复制通过创建原始对象的顶层结构的副本来工作。这意味着如果原始对象包含嵌套对象，复制将引用与原始对象相同的嵌套对象。换句话说，对对象进行浅复制会复制其最外层结构，而不会复制它可能包含的任何嵌套对象。</p>\n<p>要在 Python 中执行浅复制，您可以使用 copy 模块的 copy () 函数或对象上的 .copy () 方法。<br>\n要在 Python 中创建深度复制，可以使用 copy 模块的 deepcopy () 函数。</p>\n<p>考虑一个在 Python 中使用列表或字典的示例。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">import copy\n\nmain_list &#x3D; [29, 49, [&quot;Q&quot;, &quot;R&quot;]]\nshallow_copy &#x3D; copy.copy(main_list)\nshallow_copy2 &#x3D; copy.deepcopy(main_list)\n# 修改嵌套列表\nshallow_copy[2][0] &#x3D; 99\nmain_list[2][1] &#x3D; 100\n\nprint(f&quot;The main list: &#123;main_list&#125;&quot;)\nprint(f&quot;The shallow copy list: &#123;shallow_copy&#125;&quot;)\nprint(f&quot;The shallow copy list2: &#123;shallow_copy2&#125;&quot;)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>上面的代码中，main_list 变量包含一个包含整数和包含字母的内部列表（嵌套对象）。copy 函数创建了 main_list 的副本，代码将其存储在另一个变量 shallow_copy 中。</p>\n<p>与此同时，对 shallow_copy 或 main_list 中的外部项（整数）所做的任何更改仅会影响该实例。这些外部项本质上是独立的值，而不仅仅是引用。</p>\n<p>当您修改 deep_copy 中的嵌套列表或外部项时，您的更改不会影响原始列表，反之亦然。这表明嵌套列表或外部元素不在两个副本之间共享。</p>\n<p>在处理字典时，相同的理念也适用。</p>\n<p>#### 使用浅复制和深复制的用途</p>\n<ul>\n<li>如果您想要复制一个复杂对象而不生成其嵌套对象的新实例，则使用浅复制。这种方法比深复制更节省内存并且更快，因为它不会复制嵌套对象。</li>\n<li>如果您想要创建对象状态的快照，同时仍然在原始对象和复制对象之间共享一些基础数据，则使用浅复制。</li>\n<li>如果您想要修改对象的副本而不影响原始对象，则使用深复制。这会生成独立的嵌套对象的副本，确保对副本的任何更改不会应用于原始对象。</li>\n<li>当您需要独立副本的嵌套数据结构时，特别是在处理递归或复杂的对象层次结构时，深复制非常重要。</li>\n</ul>\n",
            "tags": [
                "Python"
            ]
        }
    ]
}