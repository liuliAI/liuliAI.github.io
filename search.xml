<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Linux(Ubuntu)服务器无法使用ssh登陆</title>
      <link href="/2024/07/28/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8ssh%E7%99%BB%E9%99%86/"/>
      <url>/2024/07/28/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8ssh%E7%99%BB%E9%99%86/</url>
      
        <content type="html"><![CDATA[<h2>Linux(Ubuntu)服务器无法使用ssh登陆</h2><p><strong>心累，每天都被服务器包围 T_T </strong></p><p><img src="/image/linux1.png" alt=""></p><p>首先 ping 服务器地址，如果不可以，参照<a href="https://liuliai.github.io/2024/07/27/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BD%91%E7%BB%9C%E9%97%AE%E9%A2%98,%E7%94%9A%E8%87%B3%E7%BD%91%E5%85%B3%E9%83%BD%E4%B8%8D%E8%83%BDping%E9%80%9A/" style="color: LimeGreen;">上篇博客</a>解决方案</p><p>如果可以 ping 通，但是使用 ssh 无法登陆，显示 connection time out</p><h4>检查SSH服务是否运行</h4><p><code>sudo systemctl status ssh</code></p><p>如果没有出现绿色的 <code>active(running)</code> ，则使用命令 <code>sudo systemctl start ssh</code>  启动 ssh 服务<br><img src="/image/linux18.png" alt=""></p><h4>检查防火墙</h4><p>如果 ssh 还是无法登陆，使用以下命令添加规则允许 22 端口的所有流量 (一般默认 22 端口)<br> iptables 防火墙系统：</p><p><code>sudo iptables -I INPUT -p tcp --dport 5922 -j ACCEPT</code></p><p>如果不确定端口，使用以下命令查看</p><p><code>sudo netstat -tulnp</code>  或者  <code>sudo ss -tulnp</code></p><p>ufw 防火墙：</p><p>修改 ssh 配置文件，将 <code>Port</code>  中后的端口设置为 22</p><p><code>sudo vim /etc/ssh/sshd_config</code></p><p>使用以下命令允许新端口的流量通过防火墙</p><p><code>sudo ufw allow 22/tcp</code></p><p>然后启用防火墙：</p><p>sudo ufw enable</p><h5>如有疑问请评论。</h5>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 教程 </tag>
            
            <tag> 服务器 </tag>
            
            <tag> SSH </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux(Ubuntu)服务器网络问题,甚至网关都不能ping通</title>
      <link href="/2024/07/27/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BD%91%E7%BB%9C%E9%97%AE%E9%A2%98,%E7%94%9A%E8%87%B3%E7%BD%91%E5%85%B3%E9%83%BD%E4%B8%8D%E8%83%BDping%E9%80%9A/"/>
      <url>/2024/07/27/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BD%91%E7%BB%9C%E9%97%AE%E9%A2%98,%E7%94%9A%E8%87%B3%E7%BD%91%E5%85%B3%E9%83%BD%E4%B8%8D%E8%83%BDping%E9%80%9A/</url>
      
        <content type="html"><![CDATA[<h2>Linux(Ubuntu)服务器网络问题,甚至网关都不能ping通</h2><p><strong>心累，每天都被服务器包围 T_T </strong></p><p><img src="/image/linux1.png" alt=""></p><p>首先使用命令 <code>route -n</code>  查看服务器网关（第一行），然后 ping 网关，如果正常表示服务器可以正常上网，使用 pip install 和 conda install 都是可以正常下载的</p><p>ping 百度，显示 100% 丢包 time out，使用常规方法即可，参考<a href="https://blog.csdn.net/weixin_43700340/article/details/88393833" style="color: LimeGreen;">博客</a>。</p><p>如果无法 ping 通网关或者 ping 百度显示 <code>ping:未知的名称或服务</code> ，则不能正常上网</p><p>使用命令 <code>vim /etc/netplan/01-network-manager-all.yaml</code>  修改配置</p><p>使用 ifconfig 获取信息并修改<br><img src="/image/linux10.jpg" alt=""></p><p>eth0 是网卡名称，gateway4 是网关，addresses 那个是 IPv4，nameservers 下面的 add 是 DNS，注意格式要跟这个一样</p><p>在执行 <code>netplan apply</code>  即可</p><p>如果还没用，那大概率是交换机的问题，换个端口就行</p><h5>如有疑问请评论。</h5>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 教程 </tag>
            
            <tag> 服务器 </tag>
            
            <tag> 网关 </tag>
            
            <tag> DNS </tag>
            
            <tag> IPv4 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux(Ubuntu)服务器重装NVIDIA驱动</title>
      <link href="/2024/07/27/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%87%8D%E8%A3%85NVIDIA%E9%A9%B1%E5%8A%A8/"/>
      <url>/2024/07/27/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%87%8D%E8%A3%85NVIDIA%E9%A9%B1%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<p><strong>心累，每天都被服务器包围 T_T </strong><br><img src="/image/linux1.png" alt=""></p><h2>Linux(Ubuntu)服务器重装NVIDIA驱动</h2><h4>下载显卡驱动</h4>准备 gpu 驱动和 CUDA 软件包，下载显卡驱动，下面是下载显卡驱动链接<p><a href="https://www.nvidia.cn/drivers/lookup/" style="color: LimeGreen;">https://www.nvidia.cn/drivers/lookup/</a></p><p>选择对应显卡下载，点击查找 ——&gt; 点击下载<br><img src="/image/linux11.jpg" alt=""></p><p>CUDA 下载链接：<a href="https://developer.nvidia.com/cuda-downloads" style="color: LimeGreen;">https://developer.nvidia.com/cuda-downloads</a>选择合适的操作系统版本进行下载。<br><img src="/image/linux12.jpg" alt=""></p><ul><li>deb 方式安装 CUDA，会附带安装显卡驱动，默认安装；</li><li>run 方式安装 CUDA，会附带安装显卡驱动，可以选择不安装；</li><li>安装显卡驱动的时候，最好安装高版本的，这样不会受 CUDA 版本的影响；</li><li>runfile：下载并运行.run 文件，可以选择是否安装 N 卡驱动；</li><li>deb：下载.deb 包，利用 apt-get install 方式安装，会自动安装.deb 包名中写的 N 卡驱动；</li><li>如果 N 卡驱动和.deb 包名中写的 N 卡驱动对应（或低于），则安装完 CUDA 之后 N 卡驱动可以正常启动。</li></ul><h4>安装显卡驱动以及 cuda</h4><h5>服务器端安装 ssh 功能</h5>` sudo apt-get install openssh-server `<p>首先将提前下载好的驱动使用 xftp 传输到命令行端，或者 U 盘挂载放入系统中</p><p>然后 ls 查看传输的驱动包是否存在，禁用系统自带的 nouveau 模块</p><p><code>sudo lsmod | grep nouveau</code></p><p><code>sudo vi /etc/modprobe.d/blacklist.conf</code></p><p>在文本最后添加以下内容：</p><pre class="line-numbers language-none"><code class="language-none">blacklist nouveauoptions nouveau modeset&#x3D;0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>保存退出，执行以下命令生效</p><p><code>update-initramfs -u</code></p><p>重启操作系统</p><p><code>sudo reboot</code></p><h4>hmod +x 给予显卡驱动包权限，以及安装软件包</h4><p>例如  <code>chmod +x NVIDIA-Linux-x86 64-550.100.run</code></p><p><code>sudo apt-get update</code></p><p><code>sudo apt-get install gcc</code></p><p><code>sudo apt-get install g++</code></p><p><code>sudo apt-get install make</code></p><h4>然后安装显卡驱动前查看 GPU 是否识别全</h4><p><code>sudo lspci | grep -i nvidia</code>  或者  <code>sudo lspci | grep -i vga</code> <br><img src="/image/linux13.png" alt=""></p><p>之后输入命令进行安装</p><p><code>sudo ./NVIDIA-Linux-x86 64-550.100.run</code></p><p>出现如下界面<br><img src="/image/linux15.png" alt=""></p><p>第一个选择选择 &quot;Continue installation&quot;，使用 <code>←</code> 和 <code>→</code> 控制</p><p>选择 &quot;No&quot;<br><img src="/image/linux16.png" alt=""></p><p>选择 &quot;Yes&quot;<br><img src="/image/linux17.png" alt=""></p><p>查看驱动包是否安装</p><p><code>nvidia-smi</code></p><p>同样的，chmod +x 给予 cuda 软件包权限，安装 cuda 软件包，sudo ./cuda-xxx.run</p><p><img src="/image/linux14.jpg" alt=""><br>注意 driver 选项，表示是否安装 GPU 驱动，如果之前已经安装了 GPU 驱动，这里不<br>要再勾选。</p><p>配置环境变量</p><p>添加到 /etc/profile 文件中</p><p><code>sudo vi /etc/profile</code></p><p>在文本最后添加以下内容：</p><pre class="line-numbers language-none"><code class="language-none">export PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;cuda&#x2F;bin:$PATH export LD_LIBRARY_PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;cuda&#x2F;lib64:$LD_LIBRARY_PATH <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>保存退出，执行以下命令生效：</p><p><code>sudo source /etc/profile</code></p><p>安装完成后查看  <code>nvcc -V </code> 是否安装成功</p><h5>如有疑问请评论。</h5>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 教程 </tag>
            
            <tag> 服务器 </tag>
            
            <tag> NVIDIA </tag>
            
            <tag> 驱动 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux(Ubuntu)服务器RAID磁盘阵列扩充硬盘</title>
      <link href="/2024/07/26/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8RAID%E7%A3%81%E7%9B%98%E9%98%B5%E5%88%97%E6%89%A9%E5%85%85%E7%A1%AC%E7%9B%98/"/>
      <url>/2024/07/26/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8RAID%E7%A3%81%E7%9B%98%E9%98%B5%E5%88%97%E6%89%A9%E5%85%85%E7%A1%AC%E7%9B%98/</url>
      
        <content type="html"><![CDATA[<p><strong>心累，每天都被服务器包围 T_T </strong><br><img src="/image/linux1.png" alt=""></p><h2>Linux(Ubuntu)服务器RAID磁盘阵列扩充硬盘</h2><p>首先关机，切断电源，把买好的硬盘插上去<br><img src="/image/linux2.jpg" alt=""></p><p>开机，等待一会，根据提示使用  <code>Ctrl+R</code>   快捷键进入阵列卡里，并使用  <code>↓</code>  选择刚刚插入的硬盘，按下 <code>F2</code> <br><img src="/image/linux3.png" alt=""><br><img src="/image/linux4.png" alt=""><br><img src="/image/linux5.png" alt=""><br><img src="/image/linux6.png" alt=""><br> 同时输入硬盘大小，点击 OK<br><img src="/image/linux7.png" alt=""><br> 格式化<br><img src="/image/linux8.png" alt=""><br>重启电脑，接着挂载即可</p><p><code>sudo  mkdir  /data</code></p><p>/dev/sdc 是装备扩充的硬盘名称，可以使用 <code>df -h</code>  或者 <code>lsblk</code>  命令查看， <code>data</code>  是要挂载的文件夹，该文件夹拥有该硬盘所有大小，要是需要分卷请参考<a href="https://blog.csdn.net/bill_wjn/article/details/106013425" style="color: LimeGreen;">博客</a></p><p><code>sudo mount  /dev/sdc  /data</code> <br> 如果报错，再使用命令 <code>mkfs -t ext4 /dev/sdc</code>  格式化</p><p>以上已经扩充完成，但是为零时挂载，每次重启电脑需要再次挂载，需要更完美的使用请继续往下看</p><p>把硬盘的 uuid 加进去<br> <code>sudo vi /etc/fstab</code></p><p>获取 uuid 命令：<br>在命令行模式下输入 <code>r! blkid /dev/sdc</code></p><p>然后按下面格式输入并保存退出，实现永久挂载<br><img src="/image/linux9.png" alt=""></p><h5>如有疑问请评论。</h5>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 教程 </tag>
            
            <tag> 服务器 </tag>
            
            <tag> RAID磁盘阵列 </tag>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>继RWKV、Mamba、KAN之后号称超越Transformer的线性架构TTT又来了</title>
      <link href="/2024/07/20/Learning%20to%20(Learn%20at%20Test%20Time)%20RNNs%20with%20Expressive%20Hidden%20States/"/>
      <url>/2024/07/20/Learning%20to%20(Learn%20at%20Test%20Time)%20RNNs%20with%20Expressive%20Hidden%20States/</url>
      
        <content type="html"><![CDATA[<h3>继RWKV、Mamba、KAN之后号称超越Transformer的线性架构TTT又来了</h3><p>最早从 23 年 5 月的<a href="https://arxiv.org/abs/2305.13048" style="color: LimeGreen;">RWKV</a>(RKWV 系列从 V1 更新到 V6，并且作者确实认真做了不少事情的)，再到去年 12 月的<a href="https://arxiv.org/abs/2312.00752" style="color: LimeGreen;">Mamba</a>，到今年 4 月的<a href="https://arxiv.org/abs/2404.19756" style="color: LimeGreen;">KAN</a>，再到 5 月的<a href="https://arxiv.org/abs/2405.21060" style="color: LimeGreen;">Mamba2</a>，到现在的<a href="https://arxiv.org/abs/2407.04620" style="color: LimeGreen;">TTT</a>。<br><strong>What KAN I say？Mamba out！T_T </strong></p><p>先简单回顾一下</p><h4>RWKV: Reinventing RNNs for the Transformer Era</h4>RWKV（Receptance Weighted Key Value） 模型的架构，和 Transformer 非常类似，也是由多个 RWKV block 组成，最后加一个 language modeling head 输出下一个 token 的分布概率。每个 RWKV block 内部，有一个 Channel Mix 和一个Time Mix 模块。<img src="/image/RWKV1.jpg" alt="语言建模的RWKV架构">RWKV block 内部的 Time Mixing 和 Channel Mixing 模块：<img src="/image/RWKV2.jpg" alt="RWKV块内的元素（左）和完整的RWKV残差块，配备有用于语言建模的最终头（右）">首先看Time-Mixing Block。Time-Mixing的目的是“Global Interaction”，对应于Transformer中的Self-Attention。<ul><li>R 表示过去的信息，用 Sigmoid 激活，遗忘机制。</li><li>W 和相对位置有关， U 对当前位置信号的补偿。</li><li>WKV 类似 Attention 功能，对位置 t ，表达了过去可学习的加权和。</li></ul><p>其中使用到的 R、K、V 对应于 Transformer 中的 Q、K、V。也就是说，K、V 的含义可以强行看作一致，把 R 当做 Q 来处理就行。只是 RKV 的计算方法有点变化：<br><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mtable columnspacing="1em" rowspacing="4pt"><mtr><mtd><msub><mi>r</mi><mrow><mi>t</mi></mrow></msub><mo>=</mo><msub><mi>W</mi><mrow><mi>r</mi></mrow></msub><mo>⋅</mo><mo stretchy="false">(</mo><msub><mi>μ</mi><mrow><mi>r</mi></mrow></msub><mo>⊙</mo><msub><mi>x</mi><mrow><mi>t</mi></mrow></msub><mo>+</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><msub><mi>μ</mi><mrow><mi>r</mi></mrow></msub><mo stretchy="false">)</mo><mo>⊙</mo><msub><mi>x</mi><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo><mo>,</mo><mstyle scriptlevel="0"><mspace width="1em"></mspace></mstyle><mo stretchy="false">(</mo><mn>11</mn><mo stretchy="false">)</mo></mtd></mtr><mtr><mtd><msub><mi>k</mi><mrow><mi>t</mi></mrow></msub><mo>=</mo><msub><mi>W</mi><mrow><mi>k</mi></mrow></msub><mo>⋅</mo><mo stretchy="false">(</mo><msub><mi>μ</mi><mrow><mi>k</mi></mrow></msub><mo>⊙</mo><msub><mi>x</mi><mrow><mi>t</mi></mrow></msub><mo>+</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><msub><mi>μ</mi><mrow><mi>k</mi></mrow></msub><mo stretchy="false">)</mo><mo>⊙</mo><msub><mi>x</mi><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo><mo>,</mo><mstyle scriptlevel="0"><mspace width="1em"></mspace></mstyle><mo stretchy="false">(</mo><mn>12</mn><mo stretchy="false">)</mo></mtd></mtr><mtr><mtd><msub><mi>v</mi><mrow><mi>t</mi></mrow></msub><mo>=</mo><msub><mi>W</mi><mrow><mi>v</mi></mrow></msub><mo>⋅</mo><mo stretchy="false">(</mo><msub><mi>μ</mi><mrow><mi>v</mi></mrow></msub><mo>⊙</mo><msub><mi>x</mi><mrow><mi>t</mi></mrow></msub><mo>+</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><msub><mi>μ</mi><mrow><mi>v</mi></mrow></msub><mo stretchy="false">)</mo><mo>⊙</mo><msub><mi>x</mi><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo><mo>,</mo><mstyle scriptlevel="0"><mspace width="1em"></mspace></mstyle><mo stretchy="false">(</mo><mn>13</mn><mo stretchy="false">)</mo></mtd></mtr></mtable></math></p><p>首先，输入经过 LayerNorm 后，将当前位置和前一个位置的输入按权重做一个 Mix，然后分别投影成 R, K, V (公式 11,12,13)。可以看到，这里就是在投影前把历史信息 Mix 起来了，越久的历史，其权重就越小（衰减速率由 μ 控制）。R 通过非线性函数 Sigmoid，得到的结果叫 Receptance，我的理解有点类似于 RNN 里的 Forget Gate 。</p><p>然后是最重要的 Attention 用了如下方法计算：<br><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>w</mi><mi>k</mi><msub><mi>v</mi><mrow><mi>t</mi></mrow></msub><mo>=</mo><mfrac><mrow><munderover><mo data-mjx-texclass="OP">∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow></munderover><msup><mi>e</mi><mrow><mo>−</mo><mo stretchy="false">(</mo><mi>t</mi><mo>−</mo><mn>1</mn><mo>−</mo><mi>i</mi><mo stretchy="false">)</mo><mi>w</mi><mo>+</mo><msub><mi>k</mi><mrow><mi>i</mi></mrow></msub></mrow></msup><mo>⊙</mo><msub><mi>v</mi><mrow><mi>i</mi></mrow></msub><mo>+</mo><msup><mi>e</mi><mrow><mi>u</mi><mo>+</mo><msub><mi>k</mi><mrow><mi>t</mi></mrow></msub></mrow></msup><mo>⊙</mo><msub><mi>v</mi><mrow><mi>t</mi></mrow></msub></mrow><mrow><munderover><mo data-mjx-texclass="OP">∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow></munderover><msup><mi>e</mi><mrow><mo>−</mo><mo stretchy="false">(</mo><mi>t</mi><mo>−</mo><mn>1</mn><mo>−</mo><mi>i</mi><mo stretchy="false">)</mo><mi>w</mi><mo>+</mo><msub><mi>k</mi><mrow><mi>i</mi></mrow></msub></mrow></msup><mo>+</mo><msup><mi>e</mi><mrow><mi>u</mi><mo>+</mo><msub><mi>k</mi><mrow><mi>t</mi></mrow></msub></mrow></msup></mrow></mfrac><mo>.</mo><mstyle scriptlevel="0"><mspace width="1em"></mspace></mstyle><mo stretchy="false">(</mo><mn>14</mn><mo stretchy="false">)</mo></math><br>WKV 这块（公式 14）是 Time Mix 的核心，它的作用就是前面提到的 RWKV 的 &quot;注意力&quot; 机制。 WKV 的计算有点类似于 Softmax，但是在分子和分母上分别加了一个当前位置<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>V</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">V_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的项。 和注意力公式差不多，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi><mi>K</mi><msub><mi>V</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">WKV_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 可以理解为：位置 t 相对于它之前各个位置的相关性（注意力程度），<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi><mi>K</mi><msub><mi>V</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">WKV_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 是一个大小为 C 的向量（C 是 channel 数）。R、K、V 的计算和 Transformer 的区别是，作为计算 RKV（QKV）的输入的 x 不再是当前 token 的 Embedding，而是当前 token 与上一个 token embedding 的加权和。</p><p>最后， Receptance 和 WKV_t 相乘（Element-Wise Product，两边都是大小为 C 的向量），得到位置 t 的输出 ot （也是大小为 C 的向量）。显然，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>o</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">o_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">o</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的计算包含了历史信息，随着 t 的增加，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>o</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">o_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">o</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 会依赖于越来越长的历史。</p><ul><li>RWKV 的优点：结合了 Transformer 和 RNN 的优势，训练时能够像 Transformer 那样并行计算，推理时又能像 RNN 那样高效。尤其是后者，对于降低模型成本，尤其是在端侧部署有重要意义。另外 RWKV 的计算量与上下文长度无关，对于更长的上下文可能有更好的扩展性。</li><li>RWKV 的缺点：和 RNN 一样，历史信息是靠隐状态（WKV）来记忆的，对于长距离历史信息的记忆不如 Transformer。这个很容易理解，因为 RWKV 的历史信息是存在一个向量里，时间越久衰减就越厉害，与 Full Attention 比自然是有局限性的。这个局限性也使得 Prompt Engineering 对 RWVK 更加重要。与 Transformer 相比，由于 RWKV 对很长的上下文记忆能力有限，如何设计提示对模型的性能会有很大影响。</li></ul><h4>Mamba: Linear-Time Sequence Modeling with Selective State Spaces</h4><p>Mamba 的架构主要基于 S4 (Structured State Spaces for Sequence Modeling)，这是一种最新的状态空间模型 (SSM，State Space  Model) 架构。详细介绍<br>可见<a href="https://blog.csdn.net/v_JULY_v/article/details/134923301" style="color: LimeGreen;">一文通透想颠覆 Transformer 的 Mamba：从 SSM、HiPPO、S4 到 Mamba</a>，内容非常详细全面，这里不再赘叙，同时也推荐一下作者七月。</p><p>Mamba 优点：</p><ul><li>改进 transformer 不擅长处理超长的序列的问题，随上下文长度的增加实现线性扩展。</li><li>快速训练和推理。在训练过程中，计算量和内存与序列长度成线性关系，而在推理过程中，由于不需要缓存以前的元素，自回归展开模型每一步只需要恒定的时间。</li></ul><p>Mamba 缺点：</p><ul><li>结构化 SSM 最初被定义为连续系统的离散化版本，对于连续时间数据（如音频、视频）具有较强的归纳偏差。</li><li>选择机制克服了结构化 SSM 在文本和 DNA 等离散数据模态上的弱点，但反过来可能会影响它们在 LTI (线性时不变) SSM 擅长的数据上的性能。</li><li>基于 Transformer 的基础模型（特别是 LLMs）具有丰富的性质和与预训练模型交互的模式，如微调、适应性、提示、上下文学习等，Mamba 可能不具有相似性质。</li><li>实证评估局限于小型模型规模，在大多数强大的开源 LLMs（如 Llama）以及其他循环模型（如 RWKV 和 RetNet）的阈值以下。评估 Mamba 在这些较大规模上是否仍然有利尚待评估。</li></ul><h4>KAN: Kolmogorov-Arnold Networks</h4><p>KAN 网络结构思路来自 Kolmogorov-Arnold 表示定理。MLP 在节点（“神经元”）上具有固定的激活函数，而 KAN 在边（“权重”）上具有可学习的激活函数。在数据拟合和 PDE 求解中，较小的 KAN 可以比较大的 MLP 获得更好的准确性。</p><p>KAN 本质上是样条（Spline）曲线和 MLP 的组合，吸收了两者的优点。即<strong>KAN = MLP + Spline</strong>（在数学中，样条曲线是由多项式分段定义的函数。一般的 Spline 可以是特定区间的 3 阶多项式。在插值问题中，样条插值通常优于多项式插值。）</p><img src="/image/KAN1.png" alt="对比"><p>与传统的 MLP 相比，KAN 有 4 个主要特点：</p><ul><li>激活函数位于 &quot;边&quot; 而不是节点（Node）上。</li><li>激活函数是可学习的而不是固定的。</li><li>可以使用非线性核函数来替代 MLP&quot;边&quot;（Edge）上的线性函数。</li><li>可以设定细粒度的结点（Knot）来提高逼近精度。</li></ul><p>KAN 优点：</p><ul><li>使用非线性算子（典型的是样条）可以更快的逼近任意函数。</li><li>精度高</li></ul><p>KAN 缺点：</p><ul><li>训练代价大，训练速度慢（KAN 通常比 MLP 慢 10 倍）。</li></ul><p><a href="https://github.com/cheng-haha/" style="color: LimeGreen;">此处</a>使用 MNIST 数据集测试 MLP 和 KAN，感兴趣的小伙伴可以试一下 (亲测可用)</p><h4>TTT：Learning to (Learn at Test Time): RNNs with Expressive Hidden States</h4>TTT 层作为一种新的信息压缩和模型记忆机制，可以简单地直接替代 Transformer 中的自注意力层。关键思想是使隐藏状态本身成为机器学习模型，而更新规则则成为自监督学习的步骤。通俗来说，在以前，习惯的做法是把某个函数的输出当作Hidden State，通常是一个向量（如RNN）或者很多向量（如Transformer）。但TTT把自己(模型)当作了Hidden State。而这个hidden state的更新是靠一次基于反向传播的更新。<img src="/image/TTT1.jpg" alt="RNN、注意力、TTT对比"><strong>序列模型会把历史上下文存储在一个隐藏状态中，这是不可避免的。</strong>像Mamba这样的RNN层，会随着时间的推移压缩成一个固定大小的状态，它们虽然效率很高，但性能受限于其表达能力。对于Transformer中的注意力机制，其有一个KV缓存，它会随着时间的推移不断增长。这个状态不会压缩任何历史上下文，但随着上下文长度的增加，成本也会越来越高。因此，TTT架构另辟蹊径，把上下文压缩到模型的权重中。与 Transformer 的Hidden State不同（每读一个token，就完整地扫描整个历史进行查找），TTT 不会随着处理数据的增多而无限扩展。相反，它会将数据编码成一组代表性的变量，即"权重"。这种形式是 TTT 模型高性能的原因，无论 TTT 模型处理多少数据，其内部模型的大小都不会改变。<p>TTT 优点：</p><ul><li>高效率。</li></ul><p>TTT 缺点：</p><ul><li>TTT 架构的验证案例相对较少，主要集中在特定任务和小规模实验中，尚未在大规模实际应用中得到广泛验证。</li></ul><p><strong>最后，我想说 TTT 的本质依然是 RNN，并且从算法的角度看，这种用空间复杂度（这种说法其实不恰当）置换时间复杂度（长上下文查找效率）的方式导致的结果就是表达能力差，直观的理解就是对于几万的 token 使用的模型参数假设是 1MB，但这 1MB 参数真的能表达几万亿的 token 内容吗，这也是作者只在 1.2B 参数内进行实验的原因吧。</strong></p><p>总结：喜大普奔，大家又可以水论文了！T_T</p>]]></content>
      
      
      <categories>
          
          <category> 论文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RWKV </tag>
            
            <tag> Mamba </tag>
            
            <tag> KAN </tag>
            
            <tag> TTT </tag>
            
            <tag> 线性架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RCL实验室Linux服务器操作手册</title>
      <link href="/2024/06/23/RCL%E5%AE%9E%E9%AA%8C%E5%AE%A4Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%93%8D%E4%BD%9C%E6%89%8B%E5%86%8C/"/>
      <url>/2024/06/23/RCL%E5%AE%9E%E9%AA%8C%E5%AE%A4Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%93%8D%E4%BD%9C%E6%89%8B%E5%86%8C/</url>
      
        <content type="html"><![CDATA[<h2>RCL实验室Linux服务器操作手册</h2>仅供东北大学机器人科学与工程学院<strong>机器人认知实验室（Robot Cognition Lab，RCL）</strong>成员使用。<p>RCL 实验室官网见<a href="http://neurcl.cn/index.html"><strong><font color="LimeGreen">此处</font></strong></a>，感兴趣获取更多详细信息。</p><h4>账号申请方法</h4><p>联系目前服务器管理员<a href="tencent://message/?Menu=yes&uin=791037420& Service=300&sigT=45a1e5847943b64c6ff3990f8a9e644d2b31356cb0b4ac6b24663a3c8dd0f8aa12a595b1714f9d45" style="color: LimeGreen;">QQ</a></p><h4>服务器介绍</h4><h5>服务器IP地址：172.17.27.199</h5><table>  <tr>    <th align="center">Device</th>    <th align="center">Parameter</th>  </tr>  <tr>    <td align="center">CPU</td>    <td align="center">2*Intel(R) Xeon(R) Silver 4314 CPU @ 2.40GHz</td>  </tr>  <tr>    <td align="center">GPU</td>    <td align="center">8*NVIDIA GeForce RTX 3090</td>  </tr>  <tr>    <td rowspan="2">ROM</td>    <td align="center">2*Intel® SSD D3-S4510 Series 480GB</td>  </tr>  <tr>    <td align="center">2*Intel® SSD D3-S4510 Series 3.84TB</td>  </tr></table><ul><li>所有存储设备均采用 RAID 1 镜像配置，确保数据冗余与安全性</li><li>操作系统版本为 Ubuntu 18.04.6 LTS</li><li>CUDA 版本为 12.1</li></ul><h5>服务器IP地址：172.17.27.194</h5><table border="1">  <tr>    <th align="center">Device</th>    <th align="center">Parameter</th>  </tr>  <tr>    <td align="center">CPU</td>    <td align="center">2*Intel(R) Xeon(R) Silver 4314 CPU @ 2.40GHz</td>  </tr>  <tr>    <td align="center">GPU</td>    <td align="center">8*NVIDIA GeForce RTX 3090</td>  </tr>  <tr>    <td align="center" rowspan="3">ROM</td>    <td align="center">2*Intel® SSD D3-S4510 Series 480GB</td>  </tr>  <tr>    <td align="center">2*Intel® SSD D3-S4510 Series 3.84TB</td>  </tr>  <tr>    <td align="center">2*致态 SC001 XT SATA SSD 2TB</td>  </tr></table><ul><li>致态 SC001 XT SATA SSD 2TB 采用 RAID 0 条带化配置，优化读写性能</li><li>其余存储设备采用 RAID 1 镜像配置，确保数据冗余与安全性</li><li>操作系统版本为 Ubuntu 18.04.6 LTS</li><li>CUDA 版本为 11.8</li></ul><h4>登陆方法</h4>目前是校内分配的ip，校外是无法访问的。<p>①使用校园网 (每个月免费 10G，凌晨 0:00-6:00 免费)，校园网具体资费标准见 <a href="https://ipgw.neu.edu.cn" style="color: LimeGreen;">此处</a>。</p><p>②使用 OpenVPN，使用学号和手机号验证码登陆，详细介绍在 <a href="http://xwb.neu.edu.cn/10185/list.htm" style="color: LimeGreen;">此处</a>。</p><h5>命令行使用</h5>在 Windows 系统中，使用"win+R"快捷键，输入"cmd"，然后回车输入ssh user@hostname 或者ssh -l user hostname ，输入密码即可。<p>ssh 登录服务器的命令如下。ssh 默认连接服务器的 22 端口，-p 参数可以指定其他端口。<br> <code>$ ssh hostname </code> <br>上面命令中，hostname 是主机名，它可以是域名，也可能是 IP 地址或局域网内部的主机名（对于 RCL 实验室，为 172.17.27.194 或者 172.17.27.199）。不指定用户名的情况下，将使用客户端的当前用户名，作为远程服务器的登录用户名。如果要指定用户名，可以采用下面的命令。<br> <code>$ ssh user@hostname </code> <br>上面的命令中，用户名和主机名写在一起了，之间使用 @分隔。用户名也可以使用 ssh 的 - l 参数指定，这样的话，用户名和主机名就不用写在一起了。<br> <code>$ ssh -l user hostname </code></p><h5>图形界面使用</h5>首先下载VNC，在此处<a href="https://www.realvnc.com/en/connect/download/viewer/windows/" style="color: LimeGreen;">官网</a>下载，或者<a href="https://pan.baidu.com/s/1qyTUfb-U2HPKqmGyg_GupQ?pwd=qn4o" style="color: LimeGreen;">百度网盘</a>。<p>然后输入 IP 地址和端口号 (端口号为最后两位，以 63 为例)<br><img src="/image/RCL-linux-fig1.jpg" alt=""><br> 点击 continue<br><img src="/image/RCL-linux-fig2.jpg" alt=""><br> 输入默认密码 123456 即可<br><img src="/image/RCL-linux-fig3.jpg" alt=""></p><h4>传输文件</h4>①在本地cmd上，可以直接通过scp命令传输文件和文件夹。<p>从本地上传到服务器，如果想要把文件夹整个上传到服务器，那么加上参数 - r 即可。</p><p><code>$ scp [-r] &#123;local_file_path&#125; &#123;user&#125;@&#123;hostname&#125;:&#123;remote_file_path&#125;</code></p><p>从远程下载到本地</p><p><code>$ scp [-r] &#123;user&#125;@&#123;hostname&#125;:&#123;remote_file_path&#125; &#123;local_file_path&#125;</code></p><p>详细使用信息见  <a href="https://www.runoob.com/linux/linux-comm-scp.html"><strong><font color="LimeGreen">此处</font></strong></a></p><p>②使用 ftp 工具 WinSCP 或者 FileZilla<br> 参考教程 <a href="https://blog.csdn.net/qq_26383975/article/details/120220823"><strong><font color="LimeGreen">文件传输工具 WinSCP 下载安装教程</font></strong></a>和<a href="https://blog.csdn.net/weixin_45309916/article/details/107782070"><strong><font color="LimeGreen">FileZilla 的下载与安装以及简单使用（有图解超简单）</font></strong></a></p><h4>文件系统介绍</h4>目前每人的账号默认分配在home中（容量较小），请将数据集，conda环境创建在data(自动备份)或者bigdata(有需要请自行备份)中进行。<p><strong>如有疑问请评论。</strong></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 教程 </tag>
            
            <tag> 服务器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cantor：Inspiring Multimodal Chain-of-Thought of MLLM</title>
      <link href="/2024/06/19/Cantor%EF%BC%9A%20Inspiring%20Multimodal%20Chain-of-Thought%20of%20MLLM/"/>
      <url>/2024/06/19/Cantor%EF%BC%9A%20Inspiring%20Multimodal%20Chain-of-Thought%20of%20MLLM/</url>
      
        <content type="html"><![CDATA[<h2>Cantor: Inspiring Multimodal Chain-of-Thought of MLLM</h2><p>本文是论文<a href="https://arxiv.org/abs/2404.16033"><strong><font color="LimeGreen">Cantor: Inspiring Multimodal Chain-of-Thought of MLLM</font></strong></a>的阅读笔记和个人理解，论文由厦门大学和腾讯优图实验室共同合作而成。探讨了一种多模态 CoT 框架，名为 Cantor，它具有感知决策架构，有效地集成了视觉上下文和逻辑推理来解决视觉推理任务。</p><p>Cantor 的特点是感知 - 决策架构。Cantor 首先充当决策生成器，并集成视觉输入来分析图像和问题，确保与实际上下文更紧密地保持一致。此外，Cantor 利用 MLLM 的高级认知功能作为多方面的专家来获取更高层次的信息，从而增强 CoT 生成过程。</p><p><strong>这种多模态思维链方法无需额外训练</strong></p><p><img src="/image/Cantor-fig1.jpg" alt=" 决策生成中视觉信息的比较"></p><h6>（a） 决策生成中视觉信息的比较：由于图像不够清晰，询问GPT-3.5（没有视觉背景）会导致“确定幻觉”。Cantor（带字幕）通过字幕引入视觉背景，不会遇到这个问题。Cantor（带图像）更加精确，提高了任务分配的合理性。（b） 不同视觉工具的比较：传统方法中使用的低级专业感知工具只能获得基本数据。由MLLM代理的高级通用认知专家获得对象数关系，实现直接和后续推理。</h6><p><strong>但我感觉这个图的比较不太恰当，在多模态 CoT 领域，却拿 GPT-3.5 这种 LLM 来做比较，只询问烧杯最大刻度，缺乏图像信息当然无法正确回答了，为什么不使用 GPT-4V 或者 Gemini 等多模态模型进行对比呢，而且 Baseline 就应该使用图像字幕的形式，而不是说 Cantor 通过字幕引入了视觉语境，避免了决策幻觉。</strong></p><blockquote><p>摘要</p></blockquote><p>随着大型语言模型 （LLMs）的出现，通过思维链 （CoT）方法得到增强，视觉推理问题通常被分解为可管理的子任务，并用各种外部工具依次解决。然而，由于视觉信息不足和低级感知工具的局限性，无法提供全面推理所需的抽象摘要，这种范式面临着决策中潜在的 “决定性幻觉” 的挑战。我们认为，融合视觉上下文获取和逻辑推理对于解决视觉推理任务至关重要。本文深入研究了多模态 CoT 领域，以多模态大型语言模型 （MLLMs）及其认知能力解决复杂的视觉推理任务。为此，我们提出了一种创新的多模态 CoT 框架，称为 Cantor，其特点是感知 - 决策架构。Cantor 首先充当决策生成器，并集成视觉输入来分析图像和问题，确保与实际上下文更紧密地保持一致。此外，Cantor 利用 MLLM 的高级认知功能作为多方面的专家来获取更高层次的信息，从而增强 CoT 生成过程。我们广泛的实验证明了所提出的框架的有效性，表明在两个复杂的视觉推理数据集中，多模态 CoT 性能显着提高，而无需微调或地面真实原理。项目页面：<br><a href="https://ggg0919.github.io/cantor/"><strong><font color="HotPink">https://ggg0919.github.io/cantor/</font></strong></a> .</p><p><img src="/image/Cantor-fig2.jpg" alt="Cantor概述和具体示例"></p><h6>Cantor概述和具体示例。Cantor通过决策生成器分析图像和问题，提供问题的原理分析，并提供模块选择和原因，以及具体的任务分配。随后，MLLM充当各种专家模块来执行子任务。最后，Cantor通过答案生成器进行综合和思考，提供最终答案。</h6><blockquote><p>引言</p></blockquote><p>随着大型语言模型 （LLMs）的发展，研究者开始采用思维链 （CoT）策略来提高模型在推理任务中的性能。CoT 模仿人类的渐进推理过程，通过构建一系列逻辑步骤来解决复杂的视觉推理问题，帮助模型提高他们的深度理解和分析能力。CoT 的有效性已在语言推理任务中得到广泛验证。最近，研究人员自然而然地将其应用扩展到了多模态域。视觉推理任务天生就适合于思维链 （CoT）方法。这些任务要求模型不仅要 “感知” 图像中的内容和上下文，还要 “理解” 这些视觉元素，以做出连贯的推理和决策。因此，多模态 CoT 的探索在研究界得到了显着扩展。大多数现有的多模态 CoT 方法分为两个阶段：决策生成和执行。1）决策生成。这是多模态 CoT 方法的第一步，涉及理解、分析和制定问题的推理计划。现有的确定方法包括将问题分解为子问题 、在图像中捕捉场景图 、查找相关图像的异同等  。他们试图在文本层面简化问题，或在视觉层面添加更多上下文信息。2）执行。在此阶段，模型执行由上一个确定阶段安排的特定操作。具体而言，该模型将规划转化为实际解决方案。现有的执行方法通常依赖于各种专门的 API 工具或视觉语言模型 （VLMs），前者强调任务执行的特殊性，后者强调任务执行的普遍性。虽然这些多模态 CoT 方法提高了视觉推理任务的性能，但仍存在局限性：首先，现有方法在做出决策时，往往直接将纯文本输入到 LLM 中，而不考虑视觉上下文。从直觉上讲，这增加了 LLM 对问题的发散性思维，但实际上，它可能导致 “确定幻觉”。如图 1（a）所示，如果问题本身与图像没有密切关系，而只是根据文本询问 “这个类测量的最高量是多少？”，则 LLM（GPT-3.5）不清楚 “这个类” 的具体含义。它会回答所提供的信息不足，并开始猜测 “类” 是指物理学中的度量还是编程中的类。这种感知的不确定性可能导致 LLM 做出与问题无关的决策，甚至是不正确的、误导性的后续执行，并导致完全不相关的答案。</p><p>其次，在执行过程中，现有方法通常通过调用外部工具来执行任务，因为 MLLM 仍然无法解决众多的视觉推理任务。但这些工具大多是低级的视觉感知工具 （检测器、识别器、OCR 等），只能提取低级的视觉信息。如图 1（b）所示，在比较溶液中的粒子数时，它们仅提供粒子的位置，而无法推断出它们数量之间的关系等高级信息。他们进一步将这些低级线索输入到 LLM 中进行组织和总结 。当复杂的线索增加时，这无疑增加了 LLM 对长文本推理的负担。同时，使用许多外部工具，也增加了管道的复杂性。为了解决上述局限性，我们提出了一种新颖的多模态 CoT 框架 Cantor。在决策生成中，我们使 MLLM 或 LLM 在合唱中充当唱者，同时处理视觉和文本上下文以进行全面理解，然后将特定任务分配给由单个 MLLM 执行的 “专家”，以进行高级逻辑问题解决。具体来说，在决策生成过程中，我们详细分析了视觉信息在决策阶段的重要性。这包括有或没有视觉信息的确定质量，以及详细或简洁的视觉信息对确定的影响的差异。最终，我们得出结论，视觉信息在决策生成阶段至关重要。当我们使用 MLLM 模型 （如 Gemini）作为决策生成器时，我们直接将图像输入到模型中，以充分理解问题并对其进行深思熟虑。然而，当采用 LLM 模型 （如 GPT-3.5）时，我们发现提供更详细的图像标题更有利于理解问题。此外，决策生成器需要明确提供解释性决策，包括解决问题的策略、专家调用的原因以及每个专家的具体任务执行。因此，它指导 MLLM 充当量身定制的专家 （例如 ObjectQuant Locator、TextIntel Extractor、VisionIQAnalyst 和 ChartSense Expert），为流程中的子任务提供结论性答案。如图 1（a）所示，当使用 LLM 做出决定时，在详细的标题指导下，模型知道它要求烧杯的最大体积并做出正确的决定。当图像可供 MLLM 使用时，决策会更加清晰，也就是说，需要 VisionIQAnalyst 提取杯壁顶部的数字。在执行过程中，我们观察到 MLLM 是一种高级认知工具，在直接获取高级信息（例如，相对位置和数量）方面比获取低级视觉信息（如检测位置）性能更好。这种高级信息对于多模态 CoT 来说是优越的。Cantor 没有使用多个外部工具，而是通过不同的专家身份和任务说明将不同的任务分配给单个 MLLM，探索充当某些专家的 MLLM 的专业潜力。量身定做的专家直接提供高水平的专业信息，从而减轻了后续综合推理的负担。如图 1（b）所示，在比较绿色颗粒的浓度时，我们需要先比较两个瓶子中的颗粒数量。MLLM 充当 ObjectQuant 定位器，直接比较两个解决方案中的数量方差。与获取粒子位置相比，MLLM 更准确地获得数量关系的结果。该结果直接应用于最终答案的进一步推断。</p><p>我们提出的框架 Cantor 在 ScinceQA 和 Mathvista 中均实现了 SOTA 结果。当 Gemini 用作决策生成器时，Cantor 分别获得 4.11% 和 5.9% 的精度增益。在 Cantor 中使用 GPT-3.5 还可以实现 2.24% 和 9.2% 的准确度增益。在我们所有的实验中，我们只使用一个 MLLM （Gemini）来扮演多个专家的角色，执行不同的子任务，有不同的要求。我们的贡献如下：</p><ul><li>我们提出了一个鼓舞人心的多模态 CoT 框架，名为 Cantor，它具有感知决策架构，有效地集成了视觉上下文和逻辑推理来解决视觉推理任务。</li><li>我们利用 MLLM 的高级认知能力，充当多方面的专家，获取更高层次的信息并显着增强 CoT 的生成。</li><li>我们在两个具有挑战性的基准测试中证明了 Cantor 的有效性，大大超过了现有的同行。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 论文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大模型 </tag>
            
            <tag> CoT </tag>
            
            <tag> 多模态 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Multimodal Large Language Model 总结</title>
      <link href="/2024/06/17/Multimodal%20Large%20Language%20Model%20%E6%80%BB%E7%BB%93/"/>
      <url>/2024/06/17/Multimodal%20Large%20Language%20Model%20%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2>Multimodal Large Language Model 总结</h2>由于最近论文工作需求，本文以总结的形式梳理了近期比较有代表性的MLLM, 推荐有基础后再阅读<h4>Revolution of Visual-Language Adapter</h4>目前的MLLM基本组成有三部分, <strong>Visual Backbone, V-L Adapter, LLM</strong><img src="/image/mllm1.jpg" alt="The Revolution of Multimodal Large Language Models: A Survey">大多数MLLM基本在LLM内部没有什么变化, Visual Encoder基本也用的CLIP的Vision Encoder, 主要区别在于Adapter上<h4>Flamingo</h4>论文: <a href="https://arxiv.org/abs/2204.14198" style="color: LimeGreen;">Flamingo: a Visual Language Model for Few-Shot Learning</a>.Flamingo代表了在LLM主干中加入Cross Attention从而用视觉增强文本表示的一派.<p>Flamingo 将视觉信息融入 LLM 的方式是在 LM Block 的主干上串行的加入一个用 Cross Attention 增强文本表示的模块，从而让文本表示中能融入视觉信息<br><img src="/image/mllm2.jpg"></p><p><strong>V 预训练 LM 为 Chinchilla 1.4 / 7 / 70B.</strong></p><p>作者在每个 LM Block 前面加上了一个 Gated Cross - Attention Block. 以 Language 为 Query, Vision input 为 Key 和 Value, 并用 Tanh 和残差做一下过滤，决定视觉增强的文本表示流通率的门控系数为全 0 初始化，跟 LoRA 有点类似.</p><p>比较有趣的是作者提到了 Flamingo 对交错图文 (Interleaved Image Text) 的数据的处理方法<br><img src="/image/mllm3.jpg"><br>在一系列文本和一系列图像构成的图文交错数据中，每个文本块中 Token 在 Cross - Attention 中只能对对应的 Visual Token 做 Attention (深蓝色), 而无法对其他 Visual Token 做 Attention (浅蓝).</p><p><strong>在作者的实验中，将作者构建的交错图文数据集去掉后，模型效果下降非常严重。也许交错图文是一个 Tricks</strong></p><h4>BLIP-2</h4><strong>BLIP-2开创了以VL对齐的Q - Former抽取视觉信息送给LLM的先河</strong>论文：<a href="https://arxiv.org/abs/2301.12597" style="color: LimeGreen;">BLIP-2: Bootstrapping Language-Image Pre-training with Frozen Image Encoders and Large Language Models</a><p>BLIP-2 提出的背景： 当前大规模模型在预训练期间的高额计算消耗太大，数据也用的特别多。作者引入一个 lightweight Querying Transformer (Q - Former) 来完成 Visual &amp; Language 模态的桥接过程<br><img src="/image/mllm4.jpg"><br>作者把 Q - Former 的训练拆分为两个阶段:</p><ul><li>首阶段：让 Q - Former 从 Freeze Image Encoder 中学习 VL 表示.</li><li>次阶段：从 Freeze LLM 中学习 VL 表示.</li></ul><p>Q - Former 结构和首阶段预训练如下<br><img src="/image/mllm5.jpg"><br>Q - Former 实际上由双塔的两个 Transformer 组成，分别被称为 Image Transformer 和 Text Transformer.</p><p>由于在首阶段中 Q - Former 已经完成了 Query 从 Image Encoder 中抽取关键信息的学习，这也就使得 Visual Signal 可以被 Query 以 Soft Visual Prompt 的形式传递给 LLM. 所以 Q - Former 中的 Text Transformer 变得不再必要，可以被丢弃. Query 表示还需要过一层 Linear Project 和大模型输入维度对齐.</p><h4>InstructBLIP</h4>论文：<a href="https://arxiv.org/abs/2305.06500" style="color: LimeGreen;">InstructBLIP: Towards General-purpose Vision-Language Models with Instruction Tuning</a>延续BLIP-2的Q - Former, 在Q - Former中添加了Instruct, 从而使得Q - Former能完成Instruction-aware Visual Feature Extraction, 从而将Visual Feature从静态的变为动态的, 能够做到instruction following，其余细节基本一致<img src="/image/mllm6.jpg"><p>与之类似的还有同样为 BLIP 系列续作的 X-InstructBLIP, 但审稿人似乎认为这种方法并没有具备很大的贡献，以及实验不够充分缺乏与当前的 MLLM 对比，于是在 ICLR 24 被拒稿了.</p><h4>LLaVA</h4>LLaVA代表了整个使用MLP为Adapter的一派<p>论文：<a href="https://arxiv.org/abs/2304.08485" style="color: LimeGreen;">Visual Instruction Tuning</a><br>与 BLIP-2 的 Q - Former 不同，LLaVA 抛弃了沉重的 Visual Extractor 设计<br><img src="/image/mllm7.jpg"><br>用预训练的 CLIP 抽取的 Visual Feature 作为 Vision Signal, 再用一次 Linear Projection 后送到 LLM 里面. LLaVA 训练的时候遵循多轮对话</p><p>作者设计了两阶段微调，让 LLM 能适配 Visual Input:</p><ul><li>Stage 1: Pre - training for Feature Alignment, 只调 Linear Projection 的参数，使 Visual Feature 和 LLM Embedding Space 对齐.</li><li>Stage 2: Fine - tuning End-to-End, 让 Linear Projection 和 LLM 一起调.</li></ul><p>比较有意思的是，LLaVA 的指令数据集是用 LLM (ChatGPT / GPT4) 生成的，通过把图像中的信息以自然语言描述出来从而传递给更高阶的 LLM, 让 LLM 生成指令数据.</p><h4>LLaVA-1.5</h4><p>论文：<a href="https://arxiv.org/abs/2310.03744" style="color: LimeGreen;">Improved Baselines with Visual Instruction Tuning</a><br>LLaVA 1.5 是 LLaVA 的改进版本<br><img src="/image/mllm8.jpg"><br>主要做了如下改动:</p><ul><li>限制了 LLM 的输出格式，让 LLaVA 直接以简短的方式回答，有利于 VQA 任务.</li><li>从一层 Linear Project 变成了两层 MLP.</li><li>加入了学术方面的数据集，用于解锁 LLaVA 对视觉区域细粒度理解能力.</li><li>提高了图像分辨率，并加入了额外数据源.</li></ul>]]></content>
      
      
      <categories>
          
          <category> 论文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多模态大模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MemoryBank：Enhancing Large Language Models with Long-Term Memory</title>
      <link href="/2024/05/24/MemoryBank%EF%BC%9AEnhancing%20Large%20Language%20Models%20with%20Long-Term%20Memory/"/>
      <url>/2024/05/24/MemoryBank%EF%BC%9AEnhancing%20Large%20Language%20Models%20with%20Long-Term%20Memory/</url>
      
        <content type="html"><![CDATA[<h2>MemoryBank：Enhancing Large Language Models with Long-Term Memory</h2><p>本文是论文<a href="https://arxiv.org/abs/2305.10250"><strong><font color="LimeGreen">MemoryBank：Enhancing Large Language Models with Long-Term Memory</font></strong></a>的阅读笔记和个人理解，论文来自 AAAI2024. 探讨了一种私人的长期记忆机制，利用持续互动随着时间推移能够适应用户个性的私人 LLM 系统。</p><p>MemoryBank 建立在一个具有内存检索和更新机制的内存存储器上，能够总结过去的事件和用户的个性。通过不断的记忆更新不断进化，通过合成以前交互的信息，随着时间的推移理解和适应用户的个性，允许 LLM 根据经过的时间和记忆的相对重要性来忘记和强化记忆，从而提供更像人类的记忆机制和丰富的用户体验（需要持续互动，如私人伴侣系统、心理咨询和秘书协助）</p><p><strong>包容性强，对 ChatGPT 这样的封闭源代码模型和像 ChatGLM 这样的开放源代码模型方面是通用的</strong></p><p>MemoryBank 思想在作者源码上体现的很简单，就是他每次出现查询请求时，都会遍历一遍历史对话记录，然后当前查询的内容遗忘保留率<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">s+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> (有具体的数学模型，可以参考链接：<a href="https://www.zhihu.com/question/364132423"><strong><font color="LimeGreen">https://www.zhihu.com/question/364132423</font></strong></a>，但是作者为了方便简化了)，作者的数学模型就是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>e</mi><mrow><mo>−</mo><mfrac><mi>t</mi><mi>s</mi></mfrac></mrow></msup></mrow><annotation encoding="application/x-tex">e^{-\frac{t}{s}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9393400000000001em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9393400000000001em;"><span style="top:-3.363em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8233428571428572em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span></span></span></span>，然后计算出这个遗忘强度值，然后用 random 随机数进行比较，当大于就删除这个，小于就保留，就实现了艾宾浩斯记忆曲线可以遗忘和增强记忆的功能。</p><p><img src="/image/MemoryBank-fig1.jpg" alt="MemoryBank概述"></p><h6>记忆存储器（§2.1）存储过去的对话、总结的事件和用户画像，而记忆更新机制（§2.3）更新记忆存储器。记忆检索（§2.2）召回相关记忆。SiliconFriend（第3节）是一个基于LLM的人工智能伴侣，基于MemoryBank。</h6><blockquote><p>摘要</p></blockquote><p>大型语言模型（LLM）的革命性进步极大地重塑了我们与人工智能（AI）系统的互动，在一系列任务中表现出令人印象深刻的性能。尽管如此，一个显著的障碍仍然存在 —— 这些模型中缺乏长期记忆机制。这种不足在需要持续互动的情况下变得越来越明显，如私人伴侣系统、心理咨询和秘书协助。认识到长期记忆的必要性，我们提出了 MemoryBank，这是一种为 LLM 量身定制的新型记忆机制。记忆库使模型能够唤起相关记忆，通过不断的记忆更新不断进化，通过合成以前交互的信息，随着时间的推移理解和适应用户的个性。为了模仿拟人行为并选择性地保存记忆，记忆库引入了一种记忆更新机制，其灵感来自埃宾浩斯遗忘曲线理论。这种机制允许人工智能根据经过的时间和记忆的相对重要性来忘记和强化记忆，从而提供更像人类的记忆机制和丰富的用户体验。MemoryBank 在容纳像 ChatGPT 这样的封闭源代码模型和像 ChatGLM 这样的开放源代码模型方面是通用的。为了验证 MemoryBank 的有效性，我们通过在长期人工智能伴侣场景中创建一个名为 SiliconFriend 的基于 LLM 的聊天机器人来举例说明其应用。进一步调整心理逻辑对话数据，SiliconFriends 在互动中表现出更高的同理心和辨别力。实验包括对真实世界用户对话框的定性分析和对模拟对话框的定量分析。在后者中，ChatGPT 充当具有不同特征的多个用户，并生成涵盖广泛主题的长期对话上下文。我们的分析结果表明，配备 MemoryBank 的 Sili-conFriend 具有很强的长期陪伴能力，因为它可以提供有力的反应，回忆相关记忆，了解用户个性。这突出了 MemoryBank 的有效性</p><blockquote><p>引言</p></blockquote><p>大型语言模型（LLM）的出现，如 ChatGPT（OpenAI，2022）和 GPT-4（Open AI，2023），导致了从教育、医疗保健到客户服务和娱乐等各个行业的影响力不断增加。这些强大的人工智能系统展示了理解和产生类似人类反应的非凡能力。尽管 LLM 具有非凡的能力，但一个关键的局限性是缺乏长期记忆，这是类人沟通的一个重要方面，在需要持续互动的场景中尤其明显，如个人陪伴、心理咨询和秘书任务。人工智能中的长期记忆对于保持上下文理解、确保有意义的交互以及随着时间的推移理解用户行为至关重要。</p><p>例如，个人人工智能同伴需要回忆过去的对话，以建立融洽的关系。在心理咨询中，人工智能可以通过了解用户的历史和过去的情绪状态来提供更有效的支持。同样，秘书人工智能需要记忆来进行任务管理和偏好识别。LLM 中长期记忆的缺失阻碍了它们的性能和用户体验。因此，开发具有改进记忆能力的人工智能系统以实现更无缝和个性化的交互至关重要。</p><p>因此，我们引入了 MemoryBank，这是一种新颖的机制，旨在为 LLM 提供保持长期记忆和绘制用户画像的能力。MemoryBank 使 LLM 能够回忆历史互动，不断发展他们对上下文的理解，并根据过去的互动适应用户的个性，从而提高他们在长期互动场景中的表现。受 Ebbinghaus 遗忘曲线理论的启发，MemoryBank 进一步融入了一种动态记忆机制，该机制密切反映了人类的认知过程。这一机制使人工智能能够记忆、选择性遗忘，并根据逝去的时间加强记忆，提供更自然、更吸引人的用户体验。具体来说，MemoryBank 建立在一个具有内存检索和更新机制的内存存储器上，能够总结过去的事件和用户的个性。</p><p>MemoryBank 是多功能的，因为它既可以容纳像 ChatGPT 这样的封闭源代码 LLM，也可以容纳像 ChapGLM（Zeng et al.，2022）或 BELLE（Yunjie Ji&amp;Li，2023）这样的开源 LLM。</p><p>为了举例说明 MemoryBank 的实际意义，我们开发了 SiliconFriend，这是一款基于 LLM 的人工智能伴侣聊天机器人，与这种创新的记忆机制相集成。SiliconFriend 旨在保留和参考过去的互动，增强 MemoryBank 在打造更具个性的人工智能伴侣方面的变革影响力。SiliconFriend 的一个显著特点是，它对从各种在线来源收集的 38k 个心理对话进行了调整，这使它能够表现出同理心、细心，并提供有用的指导，使它能够熟练地处理充满情感的对话。此外，SiliconFriend 的突出功能之一是通过总结过去的互动来了解用户的个性，这使其能够根据用户的个人特征定制反应，从而增强用户体验。此外，SiliconFriend 支持双语功能，可满足中英文交流用户的需求。这种多语言支持将其可访问性和可用性扩展到不同的用户组。SiliconFriend 通过两个开源模型 ChatGLM 和 BELLE 以及一个闭源模型 ChatGPT 实现，展示了 MemoryBank 在适应不同 LLM 方面的多功能性。</p><p>为了评估 MemoryBank 的有效性，我们进行了包括定性和定量分析的评估，其中前者涉及真实世界的用户对话，后者采用模拟对话。为了进行定量分析，我们创建了一个由 10 天的对话组成的记忆库，这些对话涵盖了各种各样的主题。这些对话涉及 15 个不同性格的虚拟用户，其中 ChatGPT 扮演用户的角色，并根据他们的性格生成对话上下文。基于这种记忆存储，我们设计了 194 个探究性问题，以评估模型是否能够成功地回忆起相关记忆并提供适当的反应。实验结果展示了 SiliconFriend 在记忆回忆、提供移情陪伴和理解用户画像方面的能力。这些发现证实了 MemoryBank 在长期互动场景中显著提高 LLM 性能的潜力。在本文中，我们将主要贡献总结如下：</p><ul><li>我们介绍了 MemoryBank，这是一种新型的类人长期记忆机制，使 LLM 能够存储、回忆、更新记忆和绘制用户画像。</li><li>我们通过 SiliconFriend 展示了 MemoryBank 的实际适用性，SiliconFriends 是一款基于 LLM 的人工智能伴侣，配备了 MemoryBank，并通过心理对话进行调整。它可以回忆过去的记忆，提供同理心的陪伴，并理解用户的行为。</li><li>我们在三个关键方面展示了 MemoryBank 的可推广性：（1）适应开源和闭源 LLM；（2） 具备中英文双语能力；（3） 具有和不具有记忆遗忘机制的适用性。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 论文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 长期记忆 </tag>
            
            <tag> RAG </tag>
            
            <tag> 大模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python多核并行操作</title>
      <link href="/2024/05/15/Python%E5%A4%9A%E6%A0%B8%E5%B9%B6%E8%A1%8C%E6%93%8D%E4%BD%9C/"/>
      <url>/2024/05/15/Python%E5%A4%9A%E6%A0%B8%E5%B9%B6%E8%A1%8C%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h2>Python多核并行操作</h2><p>如果你执行的只是很小的程序，可能单核便能满足你的要求。但是如果你要运行很大的数据类型，比如生物信息学，比如图像的预处理等，这些如果单核处理起来会非常废时间，64 核的 CPU 很多核都没有利用起来。这个时候就需要使用 CPU 的多核并行技术来提升效率。 使用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mi>t</mi><mi>o</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">htop</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span><span class="mord mathnormal">o</span><span class="mord mathnormal">p</span></span></span></span> 命令就可以看到服务器的核运行情况。</p><p>Python 默认的多进程、多线程库 multiprocessing and threading 很好用，如果你用的是 Python 默认的解析器 (CPython)，那么你只能放弃使用 threading 库，因为 GIL 的存在，多线程会让你的 Python 程序跑的比单线程还慢。当然，如果你使用的是 JPython 解析器，或者说你的解析器没有 GIL 对你程序的影响，那么你可以尝试去使用多线程。关于 GIL 的更多信息可在此处查看<a href="https://www.realvnc.com/en/connect/download/viewer/windows/" style="color: LimeGreen;">Python 的 GIL 是什么鬼，多线程性能究竟如何</a>（最近的 Python 3.12 新特性可以为每个子解释器单独创建一个 GIL，这样就可以让 Python 充分利用多核的性能，详细信息可见<a href="https://cloud.tencent.com/developer/article/2219746" style="color: LimeGreen;">Python-3.12 告别 GIL 锁 &amp; 性能原地飞升！</a>和<a href="https://www.cnblogs.com/Chang-LeHung/p/17747159.html" style="color: LimeGreen;">Python3.12 新特性 ——GIL 重大突破！</a>）</p><p>这里只讲述 Python 库 multiprocessing。<br>讲怎么使用之前，需要先明确一个概念。由于 multiprocessing 是一个创建多进程的库，那么如果你要调用的函数在同一个.py 文件下运行的话是不可以的，你分配给进程的函数需要通过 import 导入。例如：</p><pre class="line-numbers language-none"><code class="language-none">import multiprocessingdef f(x):    return x ** 2pool &#x3D; multiprocessing.Pool(processes&#x3D;5)y &#x3D; range(5)print(pool.map(f, y))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述程序是不能跑的，因为要调用的函数和 pool 的创建在同一个进程中。正确做法应该是：</p><pre class="line-numbers language-none"><code class="language-none">import multiprocessingdef f(x):    return x ** 2if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    pool &#x3D; multiprocessing.Pool(processes&#x3D;5)    y &#x3D; range(5)    print(pool.map(f, y))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>或者：</p><pre class="line-numbers language-none"><code class="language-none">import multiprocessingfrom fx import fpool &#x3D; multiprocessing.Pool(processes&#x3D;5)y &#x3D; range(5)print(pool.map(f, y))   # [0, 1, 4, 9, 16]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样做的目的是为了进程安全，<a href="https://docs.python.org/3/library/multiprocessing.html#multiprocessing-programming" style="color: LimeGreen;">更多信息</a><br>那么，明确了这个问题之后，开始讲一下 multiprocessing 如何使用。</p><h4 id="pool对象"><a class="markdownIt-Anchor" href="#pool对象">#</a> Pool 对象</h4><p>Python 提供了非常简单的 Pool 对象来实现进程池。</p><pre class="line-numbers language-none"><code class="language-none">pool &#x3D; multiprocessing.Pool(processes&#x3D;5)    # 创建进程池，并且容纳上限为5个进程。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>而 pool.map (f, y) 是对可迭代对象 y 的每个对象均使用一次 f 函数，并返回每次执行后的数据列表。 与 pool.map () 相似的还有 pool.imap () 和 pool.imap_unordered ()，不同的是后面两个返回的都是迭代器，而最后一个和名字一样，返回的数据是无序的。</p><h4 id="process对象"><a class="markdownIt-Anchor" href="#process对象">#</a> Process 对象</h4><p>具体例子</p><pre class="line-numbers language-none"><code class="language-none">import osimport multiprocessing# Mainprint(&#39;Main:&#39;, os.getpid())# worker functiondef worker(sign, lock):    lock.acquire()    print(sign, os.getpid())    lock.release()# Multi-processrecord &#x3D; []lock &#x3D; multiprocessing.Lock()if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    for i in range(5):        process &#x3D; multiprocessing.Process(target&#x3D;worker, args&#x3D;(&#39;process&#39;, lock))    # 创建进程对象，把和参数(&#39;process&#39;, lock)赋给函数worker并且让进程执行worker        process.start() # 启动进程        record.append(process)    for process in record:        process.join()  # 这里可以填入参数，效果为阻塞多少秒，如果为None那么就是终止进程。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="output"><a class="markdownIt-Anchor" href="#output">#</a> output:</h5><pre class="line-numbers language-none"><code class="language-none">Main: 96217process 96300process 96301process 96302process 96303process 96304<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这是创建进程对象并且让他自己打印自己的 PID，为了防止输出的数据是乱序的，这里加了一把进程锁 lock =multiprocessing.Lock ()，只有拿到锁的进程才能够打印自己的 PID。</p><h4 id="pipe和queue"><a class="markdownIt-Anchor" href="#pipe和queue">#</a> Pipe 和 Queue</h4><p>和名字一样，分别对应操作系统中的管道和消息队列。看两个例子：</p><pre class="line-numbers language-none"><code class="language-none">import multiprocessing as muldef proc1(pipe):    pipe.send(&#39;hello&#39;)    print(&#39;proc1 rec:&#39;, pipe.recv())def proc2(pipe):    print(&#39;proc2 rec:&#39;, pipe.recv())    pipe.send(&#39;hello, too&#39;)# Build a pipepipe &#x3D; mul.Pipe()if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    # Pass an end of the pipe to process 1    p1 &#x3D; mul.Process(target&#x3D;proc1, args&#x3D;(pipe[0],))    # Pass the other end of the pipe to process 2    p2 &#x3D; mul.Process(target&#x3D;proc2, args&#x3D;(pipe[1],))    p1.start()    p2.start()    p1.join()    p2.join()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="output-2"><a class="markdownIt-Anchor" href="#output-2">#</a> output:</h5><pre class="line-numbers language-none"><code class="language-none">proc2 rec: helloproc1 rec: hello, too<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>Pipe 对象建立的时候，返回一个含有两个元素的表，每个元素代表 Pipe 的一端 (Connection 对象)。我们对 Pipe 的某一端调用 send () 方法来传送对象，在另一端使用 recv () 来接收。</p><pre class="line-numbers language-none"><code class="language-none">import osimport multiprocessingimport timedef inputQ(queue):    info &#x3D; str(os.getpid()) + &#39;(put):&#39; + str(time.time())    queue.put(info)def outputQ(queue,lock):    info &#x3D; queue.get()    lock.acquire()    print (str(os.getpid()) + &#39; get: &#39; + info)    lock.release()    record1 &#x3D; []   # store input processesrecord2 &#x3D; []   # store output processeslock  &#x3D; multiprocessing.Lock()    # To prevent messy printqueue &#x3D; multiprocessing.Queue(3)if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    # input processes    for i in range(10):        process &#x3D; multiprocessing.Process(target&#x3D;inputQ,args&#x3D;(queue,))        process.start()        record1.append(process)        # output processes    for i in range(10):        process &#x3D; multiprocessing.Process(target&#x3D;outputQ,args&#x3D;(queue,lock))        process.start()        record2.append(process)        for p in record1:        p.join()        queue.close()  # No more object will come, close the queue        for p in record2:        p.join()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一些进程使用 put () 在 Queue 中放入字符串，这个字符串中包含 PID 和时间。另一些进程从 Queue 中取出，并打印自己的 PID 以及 get () 的字符串。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 多核并行 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>概率机器人-SALM</title>
      <link href="/2024/03/29/%E6%A6%82%E7%8E%87%E6%9C%BA%E5%99%A8%E4%BA%BA-SALM/"/>
      <url>/2024/03/29/%E6%A6%82%E7%8E%87%E6%9C%BA%E5%99%A8%E4%BA%BA-SALM/</url>
      
        <content type="html"><![CDATA[<p>记录下这门折磨的全英授课形式的课程，英语水平直线上升（但也是我所有课程中最高的成绩 97，）。同时推荐一下方老师，方老师是国内 SALM 领域中的大牛，从零几年到现在一直深耕，发表多篇顶会。 最经典的 SALM 十四讲也是好起来了，能请到方老师作序。（学 SALM 的人必看，犹如西瓜书、花书在深度学习的地位），而且方老师会带学生 DeBug，技术能力也超强。不禁让我回想起本科双语教学的最优化理论及方法，同样的大佬，同样的哀嚎一片的学生。<br><img src="/image/salm.png" alt=""></p><p>上课偷拍</p><p><video src="/image/salm.mp4" position= "absolute" width="100%" height="100%" controls="controls"></video></p><p>这是使用期末作业，使用 Jupyter 完成，有需要的，初学 SALM 的可以留言找我领取资料。<br><img src="/image/homework.jpg" alt=""><br><img src="/image/homework2.jpg" alt=""><br><img src="/image/homework1.jpg" alt=""><br><img src="/image/homework3.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 概率机器人 </tag>
            
            <tag> SALM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>矩阵分析和数值分析</title>
      <link href="/2024/03/29/%E7%9F%A9%E9%98%B5%E5%88%86%E6%9E%90%E5%92%8C%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90/"/>
      <url>/2024/03/29/%E7%9F%A9%E9%98%B5%E5%88%86%E6%9E%90%E5%92%8C%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>记录我学矩阵和数值的那些坑</p><p>####TODO</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 矩阵分析 </tag>
            
            <tag> 数值分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>四元数与万向锁</title>
      <link href="/2024/03/28/%E5%9B%9B%E5%85%83%E6%95%B0%E4%B8%8E%E4%B8%87%E5%90%91%E9%94%81/"/>
      <url>/2024/03/28/%E5%9B%9B%E5%85%83%E6%95%B0%E4%B8%8E%E4%B8%87%E5%90%91%E9%94%81/</url>
      
        <content type="html"><![CDATA[<p>最近的学习中关于四元数和万象锁出现的频率比较高，因此认真学习了，做个笔记。</p><p>在正式讨论之前，我们需要了解一些基础概念。譬如<a href="https://baike.baidu.com/item/%E6%AC%A7%E6%8B%89%E8%A7%92/1626212" style="color: LimeGreen;">欧拉角</a>。<br><img src="/image/ol.png" alt="蓝色的轴是xyz-轴，红色的轴是XYZ-坐标轴。绿色的线是交点线 (N)"></p><ul><li>\alpha  (进动角) 是 x - 轴与交点线的夹角</li><li>\beta  (章动角) 是 z - 轴与 Z - 轴的夹角</li><li>\gamma (自旋角) 是交点线与 X - 轴的夹角。</li></ul><p>简单点来说，就是分别围绕 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mi>y</mi><mi>z</mi></mrow><annotation encoding="application/x-tex">xyz</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">x</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span></span></span></span> 轴进行旋转的角度。可以用来描述三维空间中的物体旋转。但是欧拉角又有静态和动态之分。</p><p>静态欧拉角，即以固定的参考系（又称实验室参考系）来进行旋转。譬如，我们旋转一个物体，不管一个物体怎么旋转，我们整体的参考系并不会发生变化。</p><p>但静态欧拉角对于描述场景中的物体旋转并不方便，譬如一个立方体使用世界坐标系（静态欧拉角）进行旋转后，我们只需要立方体根据其自己 z 轴再进行旋转，静态欧拉角便很难进行描述。</p><p>因此我们还需要可以独立描述物体旋转的欧拉角，也就是动态欧拉角。即这时物体的 xyz 轴应该是跟着物体发生变化的。<br><strong>注意，动态欧拉角的旋转顺序对于物体最终选择是有影响的，所以只有固定的顺序（同时也正是这个顺序导致了后续的万向锁问题）才能确定物体最终的旋转姿态。因为当第一次旋转发生时，它的其余坐标轴位置也发生了改变。</strong></p><p>欧拉角旋转，在计算机中通常实现为 Y -&gt; X -&gt; Z。关于 Unity 中的旋转顺序网上资料参差不齐，有人说是 YXZ，也有人说是 ZXY。我们不妨自己打开 Unity 来试一下。</p><p>我们先绕 Z 轴（蓝色）旋转 30 度。假设 Unity 的旋转顺序是 ZXY，那么此时我们旋转 X 轴，应该会和我们想象的一样，绕红轴进行旋转。<br><img src="/image/ol1.gif" alt=""><br>很明显，立方体并非绕着 X 轴旋转，它最后的姿态，应该是先进行了 X 轴旋转，再对应进行了 Z 轴旋转。<br>我们再做一次实验。先绕 X 轴旋转 30 度，再旋转 Z 轴。<br><img src="/image/ol2.gif" alt=""><br>我们可以看到这次立方体很好地绕着 Z 轴旋转。同理再试验一下与 Y 轴的对比，因此我们可以得到顺序是 YXZ。</p><p><a href="https://baike.baidu.com/item/%E4%B8%87%E5%90%91%E9%94%81/15817326" style="color: LimeGreen;">万向锁</a>一旦选择 ±90° 作为 pitch 角，就会导致第一次旋转和第三次旋转等价，整个旋转表示系统被限制在只能绕竖直轴旋转，丢失了一个表示维度。</p><p>万向锁纯读定义来说，确实有些让人费解。<br>如果你喜欢从数学上理解，不妨<a href="https://krasjet.github.io/quaternion/bonus_gimbal_lock.pdf" style="color: LimeGreen;">点击此处</a>读一读 krasjet 大佬的数学解释 。而我则从我更直观的感受上进行介绍。做个 1 分钟的物理实验即可。</p><p>首先请读者拿出平时最常使用的手机，然后确定手机的物体坐标系朝向，假设 z 轴与手机屏幕垂直（手机平放于桌面）指向上方，手机较短的一条边为 x 轴，较长的一条边为 y 轴（方向由手机尾部指向头部），物体坐标系的原点是手机左下角的顶点。（注意旋转顺序为 zyx）</p><p>绕 z 轴旋转任意角度（注意 x 和 y 轴也跟着一起旋转），再绕 y 轴旋转 90°，再绕 x 轴旋转任意角度。通过多次尝试，会发现一个共同点：z 轴永远是水平的， 通俗的说，手机永远也不会立起来（旋转形成的三维空间是固定的）！本来以为手机会指向任何方向，但实际上手机好像是被锁在桌面上，只能指向水平的某个方向，这个现象就称为万向锁。</p><p>动态欧拉角必须按顺序旋转特性的一个体现，而万向锁正是一个极端案例。</p><p>那么我们如何解决这个问题呢？<br>这就涉及到了四元数的概念。</p><p><a href="https://baike.baidu.com/item/%E5%9B%9B%E5%85%83%E6%95%B0/5795379" style="color: LimeGreen;">四元数</a></p><p>借助<a href="https://www.bilibili.com/video/BV1SW411y7W1?t=0.0" style="color: LimeGreen;">视频</a>很容易理解复数和四元数的几何意义，非常值得一看。如果你是一个数学爱好者，文字版的数学公式推导证明在<a href="https://krasjet.github.io/quaternion/quaternion.pdf" style="color: LimeGreen;">此处</a>。</p><p>我学习之后的总结概括如下。</p><p>简而言之，我们可以从四元数的几何意义出发去理解。四元数就好比四维世界的数字。</p><p><strong>复数</strong></p><p>复数的基本形式是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi><mo>=</mo><mi>a</mi><mo>+</mo><mi>b</mi><mi>i</mi></mrow><annotation encoding="application/x-tex">z=a+bi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span><span class="mord mathnormal">i</span></span></span></span>，比如 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3.14</mn><mo>+</mo><mn>1.59</mn><mi>i</mi></mrow><annotation encoding="application/x-tex">3.14+1.59i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mord">.</span><span class="mord">1</span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">.</span><span class="mord">5</span><span class="mord">9</span><span class="mord mathnormal">i</span></span></span></span> 就是一个复数。它有一个虚数单位 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span>，定义是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>∗</mo><mi>i</mi><mo>=</mo><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i*i = -1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span>。</p><p>我们将其看作普通的平面坐标系，实数部分放置于 x 轴，虚数部分放置于 y 轴。</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 乘以一个复数相当于将其逆时针旋转 90 度，即此时由 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>+</mo><mn>0</mn><mi>i</mi></mrow><annotation encoding="application/x-tex">1+0i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord mathnormal">i</span></span></span></span> 变到了 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>+</mo><mn>1</mn><mi>i</mi></mrow><annotation encoding="application/x-tex">0+1i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord mathnormal">i</span></span></span></span> 。继续逆时针旋转 90 度，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>+</mo><mn>1</mn><mi>i</mi></mrow><annotation encoding="application/x-tex">0+1i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord mathnormal">i</span></span></span></span> 变为了 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn><mo>+</mo><mn>0</mn><mi>i</mi></mrow><annotation encoding="application/x-tex">-1+0i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord mathnormal">i</span></span></span></span>，也就是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>∗</mo><mi>i</mi><mo>=</mo><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i*i = -1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span>。所以复数相乘，就好比做矩阵变化（旋转 + 拉伸）。</p><p>同理将其扩展到四元数，便好比在三维空间做变换（旋转 + 拉伸）。</p><p>四元数乘法：（这也是我们告诉计算机该如何去计算它）</p><p>对于矩阵乘法，四元数乘法更加简洁</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.15999999999999992em" columnalign="center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msup><mi>i</mi><mn>2</mn></msup><mo>=</mo><msup><mi>j</mi><mn>2</mn></msup><mo>=</mo><msup><mi>k</mi><mn>2</mn></msup><mo>=</mo><mo>−</mo><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>i</mi><mi>j</mi><mo>=</mo><mo>−</mo><mi>j</mi><mi>i</mi><mo>=</mo><mi>k</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>k</mi><mi>i</mi><mo>=</mo><mo>−</mo><mi>i</mi><mi>k</mi><mo>=</mo><mi>j</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>j</mi><mi>k</mi><mo>=</mo><mo>−</mo><mi>k</mi><mi>j</mi><mo>=</mo><mi>i</mi></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{array}{c}i^{2}=j^{2}=k^{2}=-1 \\i j=-j i=k \\k i=-i k=j \\j k=-k j=i\end{array}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:4.800000000000001em;vertical-align:-2.1500000000000004em;"></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">i</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">−</span><span class="mord">1</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">−</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">−</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">−</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span></span></span></span></span></p><p><strong>四元数</strong><br>比如写一个四元数：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3.23</mn><mo>+</mo><mn>8.46</mn><mi>i</mi><mo>+</mo><mn>2.64</mn><mi>j</mi><mo>+</mo><mn>3.38</mn><mi>k</mi></mrow><annotation encoding="application/x-tex">3.23 + 8.46i + 2.64j + 3.38k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mord">.</span><span class="mord">2</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord">8</span><span class="mord">.</span><span class="mord">4</span><span class="mord">6</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord">2</span><span class="mord">.</span><span class="mord">6</span><span class="mord">4</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">.</span><span class="mord">3</span><span class="mord">8</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>（ <a href="https://en.wikipedia.org/wiki/William_Rowan_Hamilton" style="color: LimeGreen;">Hamilton </a>用了一个特殊的词来称呼没有标量部分只有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>j</mi><mi>k</mi></mrow><annotation encoding="application/x-tex">i j k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 分量的四元数，一个之前没有在数学和物理中出现过的词，向量（Vector）。）</p><p>对于旋转来说，我们通常使用单位四元数。</p><p>单位四元数：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>w</mi><mn>2</mn></msup><mo>+</mo><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><msup><mi>y</mi><mn>2</mn></msup><mo>+</mo><msup><mi>z</mi><mn>2</mn></msup><mo>=</mo><mn>1</mn><mspace linebreak="newline"></mspace></mrow><annotation encoding="application/x-tex">w^2 + x^2 + y^2 + z^2 = 1 \\</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.008548em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span><span class="mspace newline"></span></span></span><br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi><mo>=</mo><mn>0</mn><mo>+</mo><mn>0</mn><mi>i</mi><mo>+</mo><mn>1</mn><mi>j</mi><mo>+</mo><mn>0</mn><mi>k</mi></mrow><annotation encoding="application/x-tex">j = 0 + 0i + 1j + 0k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 相当于绕 j 轴旋转了 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>9</mn><msup><mn>0</mn><mo>∘</mo></msup></mrow><annotation encoding="application/x-tex">90^\circ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.674115em;vertical-align:0em;"></span><span class="mord">9</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.674115em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∘</span></span></span></span></span></span></span></span></span></span></span>。<br>这时，只会对变换的向量进行旋转，而不会改变其本身的大小。（模长）<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>w</mi><mn>0</mn></msub><mo>+</mo><msub><mi>x</mi><mn>0</mn></msub><mi>i</mi><mo>+</mo><msub><mi>y</mi><mn>0</mn></msub><mi>j</mi><mo>+</mo><msub><mi>z</mi><mn>0</mn></msub><mi>k</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mi>i</mi><mo>+</mo><msub><mi>y</mi><mn>1</mn></msub><mi>j</mi><mo>+</mo><msub><mi>z</mi><mn>1</mn></msub><mi>k</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><msub><mi>w</mi><mn>0</mn></msub><mo>−</mo><msub><mi>x</mi><mn>0</mn></msub><mi>i</mi><mo>−</mo><msub><mi>y</mi><mn>0</mn></msub><mi>j</mi><mo>−</mo><msub><mi>z</mi><mn>0</mn></msub><mi>k</mi><mo stretchy="false">)</mo><mspace linebreak="newline"></mspace></mrow><annotation encoding="application/x-tex">(w_0+x_0i+y_0j+z_0k)(x_1i+y_1j+z_1k)(w_0-x_0i-y_0j-z_0k)\\</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span><span class="mspace newline"></span></span></span><br> 作用：避免了欧拉角的歧义问题。</p><ul><li>优点：四元数旋转不受万向锁的影响。</li><li>局限性：单个四元数不能表示任何方向超过 180 度的旋转。</li><li>局限性：四元数的数字表示在直观上难以理解。</li></ul><p>我想从更加直观地感受上来描述一下，我们为什么使用四元数？<br>回顾一下，正如上文所说，单位四元数可以起到的作用是对三维空间物体进行旋转。</p><p>而我们想要描述物体旋转，对于用户来说，欧拉角是最直观的方式。</p><p>对于游戏引擎等来说，我们通常有一个世界坐标系，同时也希望子物体也有自己的坐标系，以便我们单独旋转子物体。这时我们不得不使用动态欧拉角。</p><p>但是动态欧拉角有缺陷，因为它必须依照固定旋转顺序（如 YXZ），才能真正确定一个旋转。因此各种仿真模拟软件通常会有其自己的固定顺序，即便用户用不同的顺序去设置 XYZ，最后也根据软件自己实现的顺序来展示物体的旋转。<br>这样才能保证 XYZ 值，只确定一个旋转。</p><p>因为旋转顺序固定，所以产生了万向锁。<br>因此我们需要一个东西它可以唯一确定并表达旋转，于是我们用到了四元数。<br>但对于用户来说，旋转场景中的物体要自己计算设置四元数显然是不友好的，因此 Unity 等方案都是在内部存储为四元数，而为了用户方便操作理解，UI 面板上则仍然使用欧拉角表示旋转（因此我们可以在软件里复现万向锁的表现），但我们只要自己知道旋转顺序，就可以在设置的时候避开它，设置出自己想要的旋转。</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 四元数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 常用命令简单介绍</title>
      <link href="/2023/10/08/Linux%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/"/>
      <url>/2023/10/08/Linux%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<p>##Linux 常用命令简单介绍<br>与 Windows 的直观图形界面相比，Linux 的命令行界面显得有些抽象，尤其是对于初涉 Linux 的朋友，每当遇到新的 Linux 命令，我们通常会花费时间在搜索引擎上查找相关的使用说明。这样的过程既耗时又繁琐。因此，我整理了一些 Linux 的基础命令，作为我学习 Linux 过程中的一个备忘录。同时也希望能够为那些想要深入探索 Linux 世界的读者提供一些帮助。</p><h4 id="apt-get-ubuntu系统包管理器"><a class="markdownIt-Anchor" href="#apt-get-ubuntu系统包管理器">#</a> apt-get   Ubuntu 系统包管理器</h4><h5 id="命令"><a class="markdownIt-Anchor" href="#命令">#</a> 命令:</h5><p>update - 检索 新的包列表<br> upgrade - 升级 可更新的所有软件包<br> install - 安装 新软件包（pkg 是 libc6 不是 libc6.deb）<br>remove - 删除 软件包<br> autoremove - 自动删除 所有未使用的软件包<br> purge - 删除 软件包和配置文件<br> clean - 清除 已下载的归档文件<br> autoclean - 清除 旧的下载的档案文件<br> check - 验证 是否有损坏的依赖<br> download - 下载 二进制包到当前目录</p><h5 id="选项"><a class="markdownIt-Anchor" href="#选项">#</a> 选项：</h5><p>-q ：不输出任何信息<br> - qq ：除了错误之外，没有输出<br> - d ：仅下载，不要安装或解压缩存档<br> - y ：对所有确定询问都选择 Yes，并且不提示<br> - f ：尝试纠正 被破坏依赖关系的系统<br> - m ：如果存档是可定位的，则尝试继续<br> - u ：显示升级包的列表<br> - b ：在获取源代码包后构建源包</p><h6 id="检索-新的包列表"><a class="markdownIt-Anchor" href="#检索-新的包列表">#</a> 检索 新的包列表</h6><p><code>apt-get update</code></p><h6 id="升级-可更新的所有软件包注意这个命令会升级所有的软件包所以会升级很长时间"><a class="markdownIt-Anchor" href="#升级-可更新的所有软件包注意这个命令会升级所有的软件包所以会升级很长时间">#</a> 升级 可更新的所有软件包（注意这个命令会升级所有的软件包，所以会升级很长时间）</h6><p><code>apt-get upgrade</code></p><h6 id="安装-nginx-软件包"><a class="markdownIt-Anchor" href="#安装-nginx-软件包">#</a> 安装 Nginx 软件包</h6><p><code>apt-get install nginx</code></p><h6 id="卸载-nginx-软件包"><a class="markdownIt-Anchor" href="#卸载-nginx-软件包">#</a> 卸载 Nginx 软件包</h6><p><code>apt-get remove nginx</code></p><h6 id="卸载-nginx-软件包-并删除所有相关配置文件"><a class="markdownIt-Anchor" href="#卸载-nginx-软件包-并删除所有相关配置文件">#</a> 卸载 Nginx 软件包 并删除所有相关配置文件</h6><p><code>apt-get remove --purge nginx</code></p><p>在安装软件和卸载的时候，为了避免误操作，都会询问是否继续，每次都要输入 y 来确定会很麻烦，可以加上 -y 参数</p><h6 id="安装-nginx-软件包-并不显示确定提示"><a class="markdownIt-Anchor" href="#安装-nginx-软件包-并不显示确定提示">#</a> 安装 Nginx 软件包 并不显示确定提示</h6><p><code>apt-get install nginx -y</code></p><h6 id="卸载-nginx-软件包删除所有相关配置文件-并不显示提示"><a class="markdownIt-Anchor" href="#卸载-nginx-软件包删除所有相关配置文件-并不显示提示">#</a> 卸载 Nginx 软件包，删除所有相关配置文件 并不显示提示</h6><p><code>apt-get remove --purge nginx -y</code></p><h6 id="清除-旧的无用-的软件包"><a class="markdownIt-Anchor" href="#清除-旧的无用-的软件包">#</a> 清除 旧的 / 无用 的软件包</h6><p><code>apt-get clean &amp;&amp; apt-get autoclean</code></p><h6 id="下载-nginx-二进制软件包到当前目录但不解压和安装"><a class="markdownIt-Anchor" href="#下载-nginx-二进制软件包到当前目录但不解压和安装">#</a> 下载 Nginx 二进制软件包到当前目录，但不解压和安装</h6><p><code>apt-get download nginx -d</code></p><h6 id="更多的命令可以用-apt-get-help-查看"><a class="markdownIt-Anchor" href="#更多的命令可以用-apt-get-help-查看">#</a> 更多的命令可以用 apt-get --help 查看。</h6><h6 id="mkdir-新建文件夹"><a class="markdownIt-Anchor" href="#mkdir-新建文件夹">#</a> mkdir 新建文件夹</h6><h6 id="在当前文件夹新建一个-bash-文件夹"><a class="markdownIt-Anchor" href="#在当前文件夹新建一个-bash-文件夹">#</a> 在当前文件夹新建一个 bash 文件夹</h6><p><code>mkdir bash</code></p><h6 id="更多的命令可以用-mkdir-help-查看"><a class="markdownIt-Anchor" href="#更多的命令可以用-mkdir-help-查看">#</a> 更多的命令可以用 mkdir --help 查看。</h6><h5>cd 进入文件夹</h5>###### 一般结合ll(小写L)命令使用(全称：ls -l)，输出当前目录下的所有目录，然后使用cd命令跳转到某个目录###### 例如当前为起始/root目录中 ，跳转到 /root/data```cd data```<h6 id="也可以多次跳转输入目录的绝对路径因此也可用作返回目录"><a class="markdownIt-Anchor" href="#也可以多次跳转输入目录的绝对路径因此也可用作返回目录">#</a> 也可以多次跳转，输入目录的绝对路径（因此也可用作返回目录）</h6><p><code>cd /root/data/user/models/</code></p><h6 id="值得注意的是在windows中的cmd使用cd命令时切换不同磁盘的目录时需要额外增加-d"><a class="markdownIt-Anchor" href="#值得注意的是在windows中的cmd使用cd命令时切换不同磁盘的目录时需要额外增加-d">#</a> 值得注意的是，在 Windows 中的 CMD 使用 cd 命令时，切换不同磁盘的目录时，需要额外增加 /d</h6><p><code>cd /d D:\Program Files\PycharmProjects\experiment</code></p><h6 id="返回上级目录"><a class="markdownIt-Anchor" href="#返回上级目录">#</a> 返回上级目录</h6><p><code>cd ..</code></p><h5>cp 复制或重命名文件/文件夹</h5>###### 复制当前目录内的 log.txt文件到 /var目录```cp log.txt /var/log.txt```<h6 id="复制当前目录内的-bash文件夹到-home目录"><a class="markdownIt-Anchor" href="#复制当前目录内的-bash文件夹到-home目录">#</a> 复制当前目录内的 bash 文件夹到 /home 目录</h6><p><code>cp -R bash /home/bash</code></p><h6 id="复制当前目录内的所有txt后缀的文件到-varlog目录"><a class="markdownIt-Anchor" href="#复制当前目录内的所有txt后缀的文件到-varlog目录">#</a> 复制当前目录内的所有.txt 后缀的文件到 /var/log 目录</h6><p><code>cp *.txt /var/log</code></p><h6 id="复制当前目录内的所有以-sy1a-5uva-4q3n开头的文件到-varlog目录"><a class="markdownIt-Anchor" href="#复制当前目录内的所有以-sy1a-5uva-4q3n开头的文件到-varlog目录">#</a> 复制当前目录内的所有以 SY1A-5UVA-4Q3N 开头的文件到 /var/log 目录</h6><p><code>cp SY1A-5UVA-4Q3N* /var/log</code></p><h6 id="复制当前目录内的所有以-sy1a-5uva-4q3n开头-以txt后缀结尾的文件到-varlog目录"><a class="markdownIt-Anchor" href="#复制当前目录内的所有以-sy1a-5uva-4q3n开头-以txt后缀结尾的文件到-varlog目录">#</a> 复制当前目录内的所有以 SY1A-5UVA-4Q3N 开头 以.txt 后缀结尾的文件到 /var/log 目录</h6><p><code>cp SY1A-5UVA-4Q3N*.txt /var/log</code></p><h6 id="假设当前目录是-rootuserlog要把这个目录中的所有txt后缀的文件复制到上一级目录-rootuser那么这样做"><a class="markdownIt-Anchor" href="#假设当前目录是-rootuserlog要把这个目录中的所有txt后缀的文件复制到上一级目录-rootuser那么这样做">#</a> 假设当前目录是 /root/user/log，要把这个目录中的所有.txt 后缀的文件复制到上一级目录 /root/user，那么这样做</h6><p><code>cp *.txt ..</code></p><h6 id="就是相对路径代表上一级目录当然你也可以用绝对路径这样更不容易出错"><a class="markdownIt-Anchor" href="#就是相对路径代表上一级目录当然你也可以用绝对路径这样更不容易出错">#</a> … 就是相对路径，代表上一级目录，当然你也可以用绝对路径，这样更不容易出错</h6><p><code>cp *.txt /root/user</code></p><h6 id="重命名当前目录内的-logtxt文件为-log2txt"><a class="markdownIt-Anchor" href="#重命名当前目录内的-logtxt文件为-log2txt">#</a> 重命名当前目录内的 log.txt 文件为 log2.txt</h6><p><code>cp log.txt log2.txt</code></p><h6 id="复制当前目录内的-logtxt文件到-var目录并重命名为-log1txt"><a class="markdownIt-Anchor" href="#复制当前目录内的-logtxt文件到-var目录并重命名为-log1txt">#</a> 复制当前目录内的 log.txt 文件到 /var 目录并重命名为 log1.txt</h6><p><code>cp log.txt /var/log1.txt</code></p><h6 id="复制当前目录内的-bash文件夹到-home目录并重命名为-bash2"><a class="markdownIt-Anchor" href="#复制当前目录内的-bash文件夹到-home目录并重命名为-bash2">#</a> 复制当前目录内的 bash 文件夹到 /home 目录并重命名为 bash2</h6><p><code>cp -R bash /home/bash2</code></p><h6 id="复制当前目录内的-logtxt文件到-var目录但是-var-目录中已经存着-logtxt那么会提示-cp-overwrite-varlogtxt-可以用-f-强制覆盖"><a class="markdownIt-Anchor" href="#复制当前目录内的-logtxt文件到-var目录但是-var-目录中已经存着-logtxt那么会提示-cp-overwrite-varlogtxt-可以用-f-强制覆盖">#</a> 复制当前目录内的 log.txt 文件到 /var 目录，但是 /var 目录中已经存着 log.txt，那么会提示 cp: overwrite `/var/log.txt’? 可以用 -f 强制覆盖</h6><p><code>cp -f log /var/log.txt</code></p><h6 id="大家可能会发现当你使用-cp-f-强制覆盖的时候依然会询问你是否覆盖这是因为-cp-为了避免你手误默认加上了-i-参数该参数代表每次覆盖必须询问"><a class="markdownIt-Anchor" href="#大家可能会发现当你使用-cp-f-强制覆盖的时候依然会询问你是否覆盖这是因为-cp-为了避免你手误默认加上了-i-参数该参数代表每次覆盖必须询问">#</a> 大家可能会发现，当你使用 cp -f 强制覆盖的时候，依然会询问你是否覆盖，这是因为 CP 为了避免你手误，默认加上了 -i 参数（该参数代表每次覆盖必须询问）。</h6><h6 id="所以想要避免-cp-默认的-i-参数只需要在-cp-命令前面加上斜杠即可"><a class="markdownIt-Anchor" href="#所以想要避免-cp-默认的-i-参数只需要在-cp-命令前面加上斜杠即可">#</a> 所以想要避免 CP 默认的 -i 参数，只需要在 CP 命令前面加上斜杠即可 “/”</h6><p><code>/cp -f log /var/log.txt</code></p><h6 id="复制当前目录内的-logtxt-log1txt-log2txt文件和-log233目录到-homelog目录中"><a class="markdownIt-Anchor" href="#复制当前目录内的-logtxt-log1txt-log2txt文件和-log233目录到-homelog目录中">#</a> 复制当前目录内的 log.txt log1.txt log2.txt 文件和 log233 目录到 /home/log 目录中</h6><p><code>cp -R log.txt log1.txt log2.txt log233 /home/log</code></p><h6 id="更多的命令可以用-cp-help-查看"><a class="markdownIt-Anchor" href="#更多的命令可以用-cp-help-查看">#</a> 更多的命令可以用 cp --help 查看。</h6><h5>mv 移动或重命名文件/文件夹</h5>###### 移动当前目录内的 log.txt文件到 /var目录```mv log.txt /var/log.txt```<h6 id="移动当前目录内的-bash文件夹到-home目录"><a class="markdownIt-Anchor" href="#移动当前目录内的-bash文件夹到-home目录">#</a> 移动当前目录内的 bash 文件夹到 /home 目录</h6><p><code>mv bash /home/bash</code></p><h6 id="重命名当前目录内的-logtxt文件为-log2txt-2"><a class="markdownIt-Anchor" href="#重命名当前目录内的-logtxt文件为-log2txt-2">#</a> 重命名当前目录内的 log.txt 文件为 log2.txt</h6><p><code>mv log.txt log2.txt</code></p><h6 id="复制当前目录内的-logtxt文件到-var目录并重命名为-log1txt-2"><a class="markdownIt-Anchor" href="#复制当前目录内的-logtxt文件到-var目录并重命名为-log1txt-2">#</a> 复制当前目录内的 log.txt 文件到 /var 目录并重命名为 log1.txt</h6><p><code>mv log.txt /var/log1.txt</code></p><h6 id="复制当前目录内的-bash文件夹到-home目录并重命名为-bash2-2"><a class="markdownIt-Anchor" href="#复制当前目录内的-bash文件夹到-home目录并重命名为-bash2-2">#</a> 复制当前目录内的 bash 文件夹到 /home 目录并重命名为 bash2</h6><p><code>mv bash /home/bash2</code></p><h6 id="更多的命令可以用-mv-help-查看"><a class="markdownIt-Anchor" href="#更多的命令可以用-mv-help-查看">#</a> 更多的命令可以用 mv --help 查看。</h6><h5>rm 删除文件/文件夹</h5>###### 删除当前目录下的 log.txt文件```rm log.txt```<h6 id="删除当前目录下所有txt后缀的文件"><a class="markdownIt-Anchor" href="#删除当前目录下所有txt后缀的文件">#</a> 删除当前目录下所有.txt 后缀的文件</h6><p><code>rm *.txt</code></p><h6 id="使用-rm-命令删除时会提示你是否确定删除输入-y-即删除输入-n-则取消"><a class="markdownIt-Anchor" href="#使用-rm-命令删除时会提示你是否确定删除输入-y-即删除输入-n-则取消">#</a> 使用 rm 命令删除时，会提示你是否确定删除，输入 y 即删除，输入 n 则取消</h6><h6 id="rm-remove-regular-file-logtxt-y"><a class="markdownIt-Anchor" href="#rm-remove-regular-file-logtxt-y">#</a> rm: remove regular file `log.txt’? y</h6><h6 id="删除当前目录下所有txt后缀的文件-2"><a class="markdownIt-Anchor" href="#删除当前目录下所有txt后缀的文件-2">#</a> 删除当前目录下所有.txt 后缀的文件</h6><p><code>rm *.txt</code></p><h6 id="删除当前目录下所有以-sy1a-5uva-4q3n开头的文件"><a class="markdownIt-Anchor" href="#删除当前目录下所有以-sy1a-5uva-4q3n开头的文件">#</a> 删除当前目录下所有以 SY1A-5UVA-4Q3N 开头的文件</h6><p><code>rm SY1A-5UVA-4Q3N*</code></p><h6 id="删除当前目录下所有以-sy1a-5uva-4q3n开头-以txt后缀结尾的文件"><a class="markdownIt-Anchor" href="#删除当前目录下所有以-sy1a-5uva-4q3n开头-以txt后缀结尾的文件">#</a> 删除当前目录下所有以 SY1A-5UVA-4Q3N 开头 以.txt 后缀结尾的文件</h6><p><code>rm SY1A-5UVA-4Q3N*.txt</code></p><h6 id="当你用-rm-删除目录的时候会发现提示这不是一个文件rm-cannot-remove-bash-is-a-directory"><a class="markdownIt-Anchor" href="#当你用-rm-删除目录的时候会发现提示这不是一个文件rm-cannot-remove-bash-is-a-directory">#</a> 当你用 rm 删除目录的时候会发现提示这不是一个文件 <code>rm: cannot remove </code> bash’: Is a directory`</h6><p><code>rm bash</code></p><h6 id="可以加上-r-来归递删除目录及其目录下的内容"><a class="markdownIt-Anchor" href="#可以加上-r-来归递删除目录及其目录下的内容">#</a> 可以加上 -r 来归递删除目录及其目录下的内容</h6><p><code>rm -r bash</code></p><h6 id="因为为了避免手误删除错误所以-rm默认是加上了-i-的参数也就是每一次删除文件目录都会提示如果觉得烦可以用-rf-参数"><a class="markdownIt-Anchor" href="#因为为了避免手误删除错误所以-rm默认是加上了-i-的参数也就是每一次删除文件目录都会提示如果觉得烦可以用-rf-参数">#</a> 因为为了避免手误删除错误，所以 rm 默认是加上了 -i 的参数，也就是每一次删除文件 / 目录都会提示，如果觉得烦可以用 -rf 参数</h6><p><code>rm -rf bash</code></p><h6 id="rm-rf-这个命令请慎重使用而且千万不要使用-rm-rf-或者-rm-rf-之类的命令系统自杀可能会让你系统爆炸所以使用请慎重"><a class="markdownIt-Anchor" href="#rm-rf-这个命令请慎重使用而且千万不要使用-rm-rf-或者-rm-rf-之类的命令系统自杀可能会让你系统爆炸所以使用请慎重">#</a> rm -rf 这个命令请慎重使用，而且千万不要使用 rm -rf / 或者 rm -rf /* 之类的命令 (系统自杀)，可能会让你系统爆炸，所以使用请慎重！</h6><h6 id="更多的命令可以用-rm-help-查看"><a class="markdownIt-Anchor" href="#更多的命令可以用-rm-help-查看">#</a> 更多的命令可以用 rm --help 查看。</h6><h5>ls 显示目录中文件（l为小写L）</h5>###### 显示当前目录下的所有文件, -a代表“all”，这个命令会列出目录中的所有文件，包括以点（.）开头的隐藏文件。它不会显示文件的详细信息，只会显示文件名。```ls -a```<h6 id="它不仅显示文件名还显示文件的权限-所有者-大小-最后修改日期等详细信息"><a class="markdownIt-Anchor" href="#它不仅显示文件名还显示文件的权限-所有者-大小-最后修改日期等详细信息">#</a> 它不仅显示文件名，还显示文件的权限、所有者、大小、最后修改日期等详细信息。</h6><p><code>ls -l</code></p><h6 id="命令后面加上-绝对路径相对路径-就会显示指定文件夹内的所有文件"><a class="markdownIt-Anchor" href="#命令后面加上-绝对路径相对路径-就会显示指定文件夹内的所有文件">#</a> 命令后面加上 绝对路径 / 相对路径 就会显示指定文件夹内的所有文件</h6><p><code>ls -a bash/log</code></p><h6 id="相对路径当前目录是-root-欲查看的目录是-rootbashlog"><a class="markdownIt-Anchor" href="#相对路径当前目录是-root-欲查看的目录是-rootbashlog">#</a> 相对路径，当前目录是 /root ，欲查看的目录是 /root/bash/log</h6><p><code>ls -a /root/bash/log</code></p><h6 id="绝对路径-当前目录是-root-欲查看的目录是-rootbashlog"><a class="markdownIt-Anchor" href="#绝对路径-当前目录是-root-欲查看的目录是-rootbashlog">#</a> 绝对路径， 当前目录是 /root ，欲查看的目录是 /root/bash/log</h6><h6 id="更多的命令可以用-ls-help-来查看"><a class="markdownIt-Anchor" href="#更多的命令可以用-ls-help-来查看">#</a> 更多的命令可以用 ls --help 来查看。</h6><h5>du 查看文件/文件夹占用磁盘空间的大小</h5>参数介绍：-h ：以人类易读的方式显示-a ：显示 目录占用的磁盘空间大小，并显示其下目录和文件占用磁盘空间的大小-s ：显示 目录占用的磁盘空间大小，但不显示其下子目录和文件占用的磁盘空间大小-c ：显示几个目录或文件占用的磁盘空间大小，还要统计它们的总和--apparent-size：显示目录或文件自身的大小-l ：统计硬链接占用磁盘空间的大小-L ：统计符号链接所指向的文件占用的磁盘空间大小<h6 id="假设当前位于-root-目录下则显示-root-文件夹的大小但不显示其子目录和文件的大小"><a class="markdownIt-Anchor" href="#假设当前位于-root-目录下则显示-root-文件夹的大小但不显示其子目录和文件的大小">#</a> 假设当前位于 /root 目录下，则显示 /root 文件夹的大小，但不显示其子目录和文件的大小</h6><p><code>du -sh</code></p><h6 id="假设当前位于-root-目录下则显示-root-文件夹的大小并显示其子目录和文件的大小"><a class="markdownIt-Anchor" href="#假设当前位于-root-目录下则显示-root-文件夹的大小并显示其子目录和文件的大小">#</a> 假设当前位于 /root 目录下，则显示 /root 文件夹的大小，并显示其子目录和文件的大小</h6><p><code>du -ah</code></p><h6 id="假设当前位于-root-目录下则显示-root-文件夹下的所有文件夹的大小及其总和"><a class="markdownIt-Anchor" href="#假设当前位于-root-目录下则显示-root-文件夹下的所有文件夹的大小及其总和">#</a> 假设当前位于 /root 目录下，则显示 /root 文件夹下的所有文件夹的大小及其总和</h6><p><code>du -lh --max-depth=1</code></p><h6 id="更多的命令可以用-du-help-来查看"><a class="markdownIt-Anchor" href="#更多的命令可以用-du-help-来查看">#</a> 更多的命令可以用 du --help 来查看。</h6><h5>cat 查看文件内容</h5>假设 log.txt文件的内容为：<p>SY1A-5UVA-4Q3N233<br>SY1A-5UVA-4Q3N</p><p>SY1A-5UVA-4Q3N666</p><p>SY1A-5UVA-4Q3N2366<br>SY1A-5UVA-4Q3N8888<br> 查看文件：</p><h6 id="查看-logtxt文件的所有内容"><a class="markdownIt-Anchor" href="#查看-logtxt文件的所有内容">#</a> 查看 log.txt 文件的所有内容</h6><p>cat log.txt</p><h6 id="输出示例如下"><a class="markdownIt-Anchor" href="#输出示例如下">#</a> 输出示例如下</h6><p>SY1A-5UVA-4Q3N233<br>SY1A-5UVA-4Q3N</p><p>SY1A-5UVA-4Q3N666</p><p>SY1A-5UVA-4Q3N2366<br>SY1A-5UVA-4Q3N8888</p><h6 id="查看-logtxt文件的所有内容并对所有行编号"><a class="markdownIt-Anchor" href="#查看-logtxt文件的所有内容并对所有行编号">#</a> 查看 log.txt 文件的所有内容，并对所有行编号</h6><p>cat -n log.txt</p><h6 id="输出示例如下-2"><a class="markdownIt-Anchor" href="#输出示例如下-2">#</a> 输出示例如下：</h6><pre><code> 1SY1A-5UVA-4Q3N233 2SY1A-5UVA-4Q3N 3 4 5SY1A-5UVA-4Q3N666 6 7SY1A-5UVA-4Q3N2366 8SY1A-5UVA-4Q3N8888</code></pre><h6 id="查看-logtxt文件的所有内容并对非空行编号"><a class="markdownIt-Anchor" href="#查看-logtxt文件的所有内容并对非空行编号">#</a> 查看 log.txt 文件的所有内容，并对非空行编号</h6><p>cat -b log.txt</p><h6 id="输出示例如下-3"><a class="markdownIt-Anchor" href="#输出示例如下-3">#</a> 输出示例如下：</h6><pre><code> 1SY1A-5UVA-4Q3N233 2SY1A-5UVA-4Q3N 3SY1A-5UVA-4Q3N666 4SY1A-5UVA-4Q3N2366 5SY1A-5UVA-4Q3N8888</code></pre><h6 id="查看-logtxt文件的所有内容并对非空行编号且不输出多行空行"><a class="markdownIt-Anchor" href="#查看-logtxt文件的所有内容并对非空行编号且不输出多行空行">#</a> 查看 log.txt 文件的所有内容，并对非空行编号，且不输出多行空行</h6><p>cat -bs log.txt</p><h6 id="输出示例如下-4"><a class="markdownIt-Anchor" href="#输出示例如下-4">#</a> 输出示例如下：</h6><pre><code> 1SY1A-5UVA-4Q3N233 2SY1A-5UVA-4Q3N 3SY1A-5UVA-4Q3N666 4SY1A-5UVA-4Q3N2366 5SY1A-5UVA-4Q3N8888</code></pre><p>清空文件：</p><h6 id="清空当前目录中的-logtxt-文件"><a class="markdownIt-Anchor" href="#清空当前目录中的-logtxt-文件">#</a> 清空当前目录中的 log.txt 文件</h6><p>cat /dev/null &gt; log.txt</p><h6 id="清空-var目录中的-logtxt-文件"><a class="markdownIt-Anchor" href="#清空-var目录中的-logtxt-文件">#</a> 清空 /var 目录中的 log.txt 文件</h6><p>cat /dev/null &gt; /var/log.txt<br> 写入文件：</p><h6 id="写入文本到当前目录中的-logtxt文件中加入文本到文件内容最后"><a class="markdownIt-Anchor" href="#写入文本到当前目录中的-logtxt文件中加入文本到文件内容最后">#</a> 写入文本到当前目录中的 log.txt 文件中 (加入文本到文件内容最后)</h6><p>cat &gt;&gt; log.txt &lt;&lt;-EOF<br>SY1A-5UVA-4Q3N<br>SY1A-5UVA-4Q3N233<br>SY1A-5UVA-4Q3N666<br>EOF</p><h6 id="清空文件并写入文本到-var目录中的-logtxt文件中先清空后写入"><a class="markdownIt-Anchor" href="#清空文件并写入文本到-var目录中的-logtxt文件中先清空后写入">#</a> 清空文件并写入文本到 /var 目录中的 log.txt 文件中 (先清空后写入)</h6><p>cat &gt; /var/log.txt &lt;&lt;-EOF<br>SY1A-5UVA-4Q3N<br>SY1A-5UVA-4Q3N233<br>SY1A-5UVA-4Q3N666<br>EOF</p><h6 id="更多的命令可以用-cat-help-来查看"><a class="markdownIt-Anchor" href="#更多的命令可以用-cat-help-来查看">#</a> 更多的命令可以用 cat --help 来查看。</h6><h5>VI、VIM 编辑文件内容</h5>###### 打开当前目录下的 log.txt文件，如果没有那么会新建 log.txt文件（安装vim后，使用 vi和 vim打开文件没区别）vi log.txtvim log.txt###### 在命令行模式下，直接输入以下 符号和字母(区分大小写)#进入编辑模式（插入模式，按 Esc键 即可返回命令行模式）i###### 删除光标当前所在的一行dd###### 删除文件内所有内容dddG###### 复制光标当前所在的一行yy###### 粘贴刚才复制的一行内容p###### 撤销上个操作（误操作可以用这个恢复）u###### 保存当前文件（ : 是英文的冒号）:w###### 另存当前文件内容为 log2.txt:w log2.txt###### 退出当前文件:q###### 不保存 并强制退出当前文件:q!###### 保存并退出当前文件:wq<h6 id="更多的命令可以用-vi-help-vim-help-来查看"><a class="markdownIt-Anchor" href="#更多的命令可以用-vi-help-vim-help-来查看">#</a> 更多的命令可以用 vi --help /vim --help 来查看。</h6><h5>wget 下载工具</h5>参数介绍：<h6 id="只介绍最常用的参数"><a class="markdownIt-Anchor" href="#只介绍最常用的参数">#</a> 只介绍最常用的参数</h6><h6 id="如果提示命令不存在那么使用-yum-install-wget-y-apt-get-install-wget-y-来安装有一些非常精简的系统可能会没装"><a class="markdownIt-Anchor" href="#如果提示命令不存在那么使用-yum-install-wget-y-apt-get-install-wget-y-来安装有一些非常精简的系统可能会没装">#</a> 如果提示命令不存在，那么使用 yum install wget -y /apt-get install wget -y 来安装（有一些非常精简的系统可能会没装）</h6><p>-b ：启动后，后台下载<br> - q ：安静模式（不输出任何信息）<br>-c ：断点续传下载文件<br> - O ：指定下载后的文件名（可使用绝对路径目录 + 文件名）<br>-P ：指定下载后的文件目录（-P 只能指定下载目录，并不能指定文件名）<br>-t ：设置重试次数（0 代表无限）<br>-T ：设置超时时间（单位：秒）<br>-N ：只获取比本地新的文件（新的覆盖旧的）<br>-4 ：仅连接至 IPv4 地址<br> - 6 ：仅连接至 IPv6 地址<br>–limit-rate=xxxk : 限制下载速度（k 代表 KB/S）<br>–post-data ：通过 POST 方式发送数据<br>–no-check-certificate ：不验证服务器的 SSL 证书</p><h6 id="下载一个文件到当前目录"><a class="markdownIt-Anchor" href="#下载一个文件到当前目录">#</a> 下载一个文件到当前目录</h6><p><code>wget https://yun.doubibackup.com/100MB.bin</code></p><h6 id="下载文件到当前目录并重命名为-200mbbin"><a class="markdownIt-Anchor" href="#下载文件到当前目录并重命名为-200mbbin">#</a> 下载文件到当前目录并重命名为 200MB.bin</h6><p><code>wget -O &quot;200MB.bin&quot; https://yun.doubibackup.com/100MB.bin</code></p><h6 id="下载文件到-root目录-p只能指定下载目录并不能指定文件名"><a class="markdownIt-Anchor" href="#下载文件到-root目录-p只能指定下载目录并不能指定文件名">#</a> 下载文件到 /root 目录（-P 只能指定下载目录，并不能指定文件名）</h6><p><code>wget -P &quot;/root&quot; https://yun.doubibackup.com/100MB.bin</code></p><h6 id="下载文件到-rootdoubi目录并重命名为-200mbbin"><a class="markdownIt-Anchor" href="#下载文件到-rootdoubi目录并重命名为-200mbbin">#</a> 下载文件到 /root/doubi 目录并重命名为 200MB.bin</h6><p><code>wget -O &quot;/root/doubi/200MB.bin&quot; https://yun.doubibackup.com/100MB.bin</code></p><h6 id="下载文件完成之前-wget进程结束了那么可以使用断点续传重新下载中断的文件前提是下载服务器支持断点续传"><a class="markdownIt-Anchor" href="#下载文件完成之前-wget进程结束了那么可以使用断点续传重新下载中断的文件前提是下载服务器支持断点续传">#</a> 下载文件完成之前 wget 进程结束了，那么可以使用断点续传重新下载中断的文件（前提是下载服务器支持断点续传）</h6><p><code>wget -c https://yun.doubibackup.com/100MB.bin</code></p><h6 id="通过后台下载文件到-rootdoubi目录并重命名为-200mbbin"><a class="markdownIt-Anchor" href="#通过后台下载文件到-rootdoubi目录并重命名为-200mbbin">#</a> 通过后台下载文件到 /root/doubi 目录并重命名为 200MB.bin</h6><p><code>wget -b -O &quot;/root/doubi/200MB.bin&quot; https://yun.doubibackup.com/100MB.bin</code></p><h6 id="continuing-in-background-pid-2333"><a class="markdownIt-Anchor" href="#continuing-in-background-pid-2333">#</a> Continuing in background, pid 2333.</h6><h6 id="output-will-be-written-to-wget-log"><a class="markdownIt-Anchor" href="#output-will-be-written-to-wget-log">#</a> Output will be written to `wget-log’.</h6><h6 id="后台下后你可以使用以下命令来查看下载进度"><a class="markdownIt-Anchor" href="#后台下后你可以使用以下命令来查看下载进度">#</a> 后台下后，你可以使用以下命令来查看下载进度：</h6><p><code>tail -f wget-log</code></p><h6 id="有时候一些linux系统中的ssl证书不完整会导致下载一些-https网站文件的时候会验证ssl证书失败可以这样做"><a class="markdownIt-Anchor" href="#有时候一些linux系统中的ssl证书不完整会导致下载一些-https网站文件的时候会验证ssl证书失败可以这样做">#</a> 有时候一些 Linux 系统中的 SSL 证书不完整，会导致下载一些 HTTPS 网站文件的时候会验证 SSL 证书失败，可以这样做</h6><h6 id="不验证服务器ssl证书下载文件到当前目录并重命名为-200mbbin"><a class="markdownIt-Anchor" href="#不验证服务器ssl证书下载文件到当前目录并重命名为-200mbbin">#</a> 不验证服务器 SSL 证书，下载文件到当前目录并重命名为 200MB.bin</h6><p><code>wget --no-check-certificate -O &quot;200MB.bin&quot; https://yun.doubibackup.com/100MB.bin</code></p><h6 id="使用wget发送post请求数据"><a class="markdownIt-Anchor" href="#使用wget发送post请求数据">#</a> 使用 wget 发送 POST 请求数据</h6><p><code>wget --post-data &quot;user=doubi&amp;passwd=23333&quot; https://xxx.xx/</code></p><h6 id="下载文件到当前目录-并仅通过ipv4连接-只获取比本地新的文件限速-200kbs"><a class="markdownIt-Anchor" href="#下载文件到当前目录-并仅通过ipv4连接-只获取比本地新的文件限速-200kbs">#</a> 下载文件到当前目录 并仅通过 IPv4 连接 只获取比本地新的文件，限速 200KB/S</h6><p><code>wget --limit-rate=200k -N -4 https://yun.doubibackup.com/100MB.bin</code></p><h6 id="下载文件到当前目录-并重试次数为-1超时时间为-2秒"><a class="markdownIt-Anchor" href="#下载文件到当前目录-并重试次数为-1超时时间为-2秒">#</a> 下载文件到当前目录 并重试次数为 1，超时时间为 2 秒</h6><p><code>wget -t1 -T2 https://yun.doubibackup.com/100MB.bin</code></p><h6 id="通过-wget来获取服务器的外网ip-qo-代表运行完会输出下载的信息并不会保存到本地文件"><a class="markdownIt-Anchor" href="#通过-wget来获取服务器的外网ip-qo-代表运行完会输出下载的信息并不会保存到本地文件">#</a> 通过 wget 来获取服务器的外网 IP（-qO- 代表运行完会输出下载的信息，并不会保存到本地文件）</h6><p><code>wget -qO- ipinfo.io/ip</code></p><h6 id="更多的命令可以用-wget-help-来查看"><a class="markdownIt-Anchor" href="#更多的命令可以用-wget-help-来查看">#</a> 更多的命令可以用 wget --help 来查看。</h6>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第十四届全国大学生电工杯数学建模竞赛</title>
      <link href="/2023/10/08/%E7%AC%AC%E5%8D%81%E5%9B%9B%E5%B1%8A%E5%85%A8%E5%9B%BD%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%94%B5%E5%B7%A5%E6%9D%AF%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E7%AB%9E%E8%B5%9B/"/>
      <url>/2023/10/08/%E7%AC%AC%E5%8D%81%E5%9B%9B%E5%B1%8A%E5%85%A8%E5%9B%BD%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%94%B5%E5%B7%A5%E6%9D%AF%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E7%AB%9E%E8%B5%9B/</url>
      
        <content type="html"><![CDATA[<p>时隔一年，记录下，实在懒，没有什么内容好更了。</p><p>没有哪次竞赛比这次更累了，建模、编程、论文三合一，加班加点的通宵，比完直接躺了两天。当然，对于自己各方面的提升也是巨大的，最后也是不负众望，和室友、班长共同努力下取得了一等奖。<br><img src="/image/dgb.png" alt=""></p><p>B 题如下<br><img src="/image/dgb2.jpg" alt=""></p><p>第一问很简单是可重复访问的 TSP 问题，有多种方法，例如多次 Dijkstra + 剪枝优化，暴力枚举 + 剪枝优化（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">!</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n!)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">!</span><span class="mclose">)</span></span></span></span>），遗传算法，状压 DP（状态压缩动态规划，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>⋅</mo><msup><mn>2</mn><mi>n</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^{2}\cdot 2^{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>）等等。由于数量级问题，遗传算法大概 2 分钟，其他算法不推荐。<br>状压 DP 代码如下：</p><pre class="line-numbers language-none"><code class="language-none">import sysdef tsp(dp, mask, pos, dist, n):    # 如果所有城市都访问过，返回当前位置到起点的距离    if mask &#x3D;&#x3D; (1 &lt;&lt; n) - 1:        return dist[pos][0]        # 如果这个状态已经计算过，直接返回结果    if dp[mask][pos] !&#x3D; -1:        return dp[mask][pos]        ans &#x3D; sys.maxsize    # 尝试访问每个城市    for i in range(n):        # 如果这个城市还没有被访问过        if (mask &amp; (1 &lt;&lt; i)) &#x3D;&#x3D; 0:            # 计算通过这个城市到下一个城市的新路径长度            newAns &#x3D; dist[pos][i] + tsp(dp, mask | (1 &lt;&lt; i), i, dist, n)            ans &#x3D; min(ans, newAns)        # 记录并返回当前状态的最短路径长度    dp[mask][pos] &#x3D; ans    return ans<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第二问复杂的多，改进遗传算法，增加一条代表无人机路径的染色体并且由于无人机载重限制，同一地点可能需要重复飞行，将配送地点当日物资需求量利用阶跃函数和取整函数进行分界设置为无人机染色体中该地点基因的权重，由此控制变异之后该地点基因出现概率。得出完成一次整体配送的最优方案时间。</p><p>第三问延续第二问进行二次改进，设置配送车辆染色体 9 号基因的权重为较大值，即可使配送车辆染色体以较大的变异概率出现 9 号基因，即中途返回出发地，得出完成一次整体配送最优方案时间。</p><p>第四问由于计划设置两个应急物资集中地点，因此使用 K-median 聚类方法进行聚类，同时，将各地点当日物资需求量作为聚类点集权重，聚类得出两个应急物资中心点为地点 5 和地点 25，且将图分为两部分，之后使用问题三中改进的遗传算法计算两次，分别得出两个应急物资点完成一次整体配送的最优方案。</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学建模 </tag>
            
            <tag> 电工杯 </tag>
            
            <tag> 遗传算法 </tag>
            
            <tag> 状压DP </tag>
            
            <tag> TSP旅行商 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 中的正则表达式</title>
      <link href="/2023/10/05/%E5%9C%A8%20Python%20%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2023/10/05/%E5%9C%A8%20Python%20%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2>Python 中的正则表达式</h2><p>每当你遇到文本处理问题时，正则表达式（regex）不可或缺（在算法题目中也会出现）。</p><h3 id="验证电子邮件地址"><a class="markdownIt-Anchor" href="#验证电子邮件地址">#</a> 验证电子邮件地址</h3><pre class="line-numbers language-none"><code class="language-none">import redef val_email(email):    pattern &#x3D; r&quot;^[a-zA-Z0-9]+@[a-zA-Z0-9]+\.[a-zA-Z]&#123;2,&#125;$&quot;    if re.match(pattern, email):        print(&quot;合法的邮件地址:)&quot;)    else:        print(&quot;无效的邮件地址!!&quot;)val_email(email&#x3D;&quot;elon@example.com&quot;)# 合法的邮件地址val_email(email&#x3D;&quot;elonexample.com&quot;)# 无效的邮件地址!!val_email(email&#x3D;&quot;elon@example.c&quot;)# 无效的邮件地址!!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个例子中，我们使用 Python 中的 re 模块来编译一个匹配有效电子邮件格式的正则表达式模式。然后，我们使用它的 match () 函数来检查 email 变量是否与模式匹配。</p><p>在模式中，有几个关键点：</p><ul><li>我们使用 [] 表示一个范围。例如，[a-zA-Z0-9] 可以匹配 0 到 9 之间的数字、A 到 Z 之间的字母或 a 到 z 之间的字母。</li><li>^ 表示行的开头。在我们的例子中，我们使用它来确保文本必须以 [a-zA-Z0-9] 开始。</li><li>$ 表示行的结尾。</li><li>\ 用于转义特殊字符（允许我们匹配像 ‘.’ 这样的字符）。</li><li>{n,m} 语法是用来匹配 n-m 个先前的正则表达式。我们使用了 {2,}，这意味着前面的部分 [a-zA-Z] 应该至少重复 2 次。这就是为什么 “elon@example.c” 被识别为无效的电子邮件地址。</li><li>. 表示匹配前面的正则表达式至少 1 次。例如，ab+ 将匹配 a 后面的任何非零数量的 b。</li></ul><h3 id="从字符串中提取数字"><a class="markdownIt-Anchor" href="#从字符串中提取数字">#</a> 从字符串中提取数字</h3><p>要从长文本中找到一些特殊字符，最直接的想法是使用 for 循环遍历所有字符并找到所需的内容。</p><p>但是，没有必要使用任何循环。正则表达式就是为了作为过滤器而生的。（时间复杂度更低，更快！！）</p><pre class="line-numbers language-none"><code class="language-none">import redef extract_numbers(text):    pattern &#x3D; r&quot;\d+&quot;    return re.findall(pattern, text)print(extract_numbers(&quot;先将键盘1上的三4行字母5进行6打表100000000。&quot;))# [&#39;1456100000000&#39;]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>re.findall () 函数接收一个正则表达式和一个文本，可以方便地帮助我们找到所有我们需要的字符。</p><p>其中 \d 用于在正则表达式中匹配数字。</p><h3 id="验证有效电话号码"><a class="markdownIt-Anchor" href="#验证有效电话号码">#</a> 验证有效电话号码</h3><pre class="line-numbers language-none"><code class="language-none">import redef is_valid_phone_number(phone_number):    pattern &#x3D; r&quot;^\d&#123;3&#125;-\d&#123;3&#125;-\d&#123;4&#125;$&quot;    return bool(re.match(pattern, phone_number))print(is_valid_phone_number(&quot;123-456-7890&quot;))  # Trueprint(is_valid_phone_number(&quot;1234567890&quot;))  # False<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="将文本分割成单词"><a class="markdownIt-Anchor" href="#将文本分割成单词">#</a> 将文本分割成单词</h3><p>将长文本分割成单独的单词是日常编程中的另一个常见需求。借助 re 模块的 split () 函数，我们可以轻松完成此任务：</p><pre class="line-numbers language-none"><code class="language-none">re.split(r&#39;\s+&#39;, &#39;a b   c&#39;)# [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]re.split(r&#39;[\s\,]+&#39;, &#39;a,b, c  d&#39;)# [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]re.split(r&#39;[\s\,\;]+&#39;, &#39;a,b;; c  d&#39;)[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="使用正则表达式查找和替换文本"><a class="markdownIt-Anchor" href="#使用正则表达式查找和替换文本">#</a> 使用正则表达式查找和替换文本</h3><pre class="line-numbers language-none"><code class="language-none">import retext &#x3D; &quot;linuxmi is an full-stack software engineer.&quot;pattern &#x3D; r&quot;[a-e]&quot;replacement &#x3D; &quot;*&quot;new_text &#x3D; re.sub(pattern, replacement, text)print(new_text)  #linuxmi is *n full-st**k softw*r* *ngin**r.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解 Python 中的浅复制和深复制</title>
      <link href="/2023/10/05/%E7%90%86%E8%A7%A3%20Python%20%E4%B8%AD%E7%9A%84%E6%B5%85%E5%A4%8D%E5%88%B6%E5%92%8C%E6%B7%B1%E5%A4%8D%E5%88%B6/"/>
      <url>/2023/10/05/%E7%90%86%E8%A7%A3%20Python%20%E4%B8%AD%E7%9A%84%E6%B5%85%E5%A4%8D%E5%88%B6%E5%92%8C%E6%B7%B1%E5%A4%8D%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2>理解 Python 中的浅复制和深复制</h2>Python 提供了多种有效的方法来管理数据。在处理嵌套列表、字典或自定义对象等数据结构时，理解浅复制和深复制的概念是至关重要的。<p>在 Python 中，浅拷贝和深拷贝是两种不同的拷贝方式。浅拷贝只复制引用，不复制内部对象，而深拷贝则完全复制整个对象，包括其内部的子对象。尤其是在算法中，可能需要用到拷贝的概念来解决问题，如列表、字符串等数据结构（初学者包括我会犯的错， <code>a=[1,2,3,4]</code> ，然后又使用 <code>b=a</code> ，然后在 b 上修改列表，导致 a 也发生变化）</p><p>浅拷贝在 Python 中可以通过几种方式实现，如使用 copy 模块的 copy () 函数，切片操作 [:]，以及字典和集合的拷贝方法.copy ()。深拷贝则可以通过 copy 模块的 deepcopy () 函数来实现。在选择拷贝方式时，重要的是理解对象的结构和需求，以确保拷贝行为符合预期。</p><p>使用浅复制<br>浅复制通过创建原始对象的顶层结构的副本来工作。这意味着如果原始对象包含嵌套对象，复制将引用与原始对象相同的嵌套对象。换句话说，对对象进行浅复制会复制其最外层结构，而不会复制它可能包含的任何嵌套对象。</p><p>要在 Python 中执行浅复制，您可以使用 copy 模块的 copy () 函数或对象上的 .copy () 方法。<br>要在 Python 中创建深度复制，可以使用 copy 模块的 deepcopy () 函数。</p><p>考虑一个在 Python 中使用列表或字典的示例。</p><pre class="line-numbers language-none"><code class="language-none">import copymain_list &#x3D; [29, 49, [&quot;Q&quot;, &quot;R&quot;]]shallow_copy &#x3D; copy.copy(main_list)shallow_copy2 &#x3D; copy.deepcopy(main_list)# 修改嵌套列表shallow_copy[2][0] &#x3D; 99main_list[2][1] &#x3D; 100print(f&quot;The main list: &#123;main_list&#125;&quot;)print(f&quot;The shallow copy list: &#123;shallow_copy&#125;&quot;)print(f&quot;The shallow copy list2: &#123;shallow_copy2&#125;&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的代码中，main_list 变量包含一个包含整数和包含字母的内部列表（嵌套对象）。copy 函数创建了 main_list 的副本，代码将其存储在另一个变量 shallow_copy 中。</p><p>与此同时，对 shallow_copy 或 main_list 中的外部项（整数）所做的任何更改仅会影响该实例。这些外部项本质上是独立的值，而不仅仅是引用。</p><p>当您修改 deep_copy 中的嵌套列表或外部项时，您的更改不会影响原始列表，反之亦然。这表明嵌套列表或外部元素不在两个副本之间共享。</p><p>在处理字典时，相同的理念也适用。</p><p>#### 使用浅复制和深复制的用途</p><ul><li>如果您想要复制一个复杂对象而不生成其嵌套对象的新实例，则使用浅复制。这种方法比深复制更节省内存并且更快，因为它不会复制嵌套对象。</li><li>如果您想要创建对象状态的快照，同时仍然在原始对象和复制对象之间共享一些基础数据，则使用浅复制。</li><li>如果您想要修改对象的副本而不影响原始对象，则使用深复制。这会生成独立的嵌套对象的副本，确保对副本的任何更改不会应用于原始对象。</li><li>当您需要独立副本的嵌套数据结构时，特别是在处理递归或复杂的对象层次结构时，深复制非常重要。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vision-and-Language Navigation  A Survey of Tasks, Methods, and Future Directions</title>
      <link href="/2023/05/10/Vision-and-Language%20Navigation%20A%20Survey%20of%20Tasks%20Methods%20and%20Future%20Directions/"/>
      <url>/2023/05/10/Vision-and-Language%20Navigation%20A%20Survey%20of%20Tasks%20Methods%20and%20Future%20Directions/</url>
      
        <content type="html"><![CDATA[<h2>Vision-and-Language Navigation: A Survey of Tasks, Methods, and Future Directions</h2><p>本文是论文<a href="https://arxiv.org/pdf/2203.12667" style="color: LimeGreen;">Vision-and-Language Navigation: A Survey of Tasks, Methods, and Future Directions</a>的阅读笔记和个人理解，论文由加州大学和阿德莱德大学等单位共同合作而成，发表于 ACL 2022。</p><p>论文的全文翻译在<a href="https://zhuanlan.zhihu.com/p/620780945" style="color: LimeGreen;">本人知乎</a>参考，便于读者快速阅读，以下是本人的阅读笔记和个人理解，如有错误之处，恳请批评指正。</p><p><img src="/image/VLN1.jpg" alt=""><br>VLN 全称 Vision-and-Language Navigation，是为了构建能够用自然语言与人类交流、感知环境并执行现实世界任务的智能体，一般认为 VLN 需要有三个要素，Environment、Agent and Oracle。</p><p><strong>VLN 是 Embodied AI 中的一类，Embodied AI 又是 AGI（Artificial General Intelligence）的一小类，因此 VLN 的研究十分有意义，但是 VLN 将 vision、language 和 action 这三种模态融合到一起，对输入信息的理解要求很高，并且目前数据集较少，比较复杂，实现困难。</strong></p><p>首先，VLN 可以极大程度解放人的劳动。例如在家里可以让 agent 帮我们从厨房拿苹果，或者拿个勺子，或者取快递，外卖之类的，或者危险任务，火灾救人，拆炸弹。VLN 是要求人和 Agent 互相合作，在环境中去完成迁移任务，Agent 可以实时传送画面给我们，然后我们可以使用自然语言告诉它接下来应该怎么做。</p><p><img src="/image/VLN2.png" alt=""><br>论文将当前数据集分为两个轴第一个是 Communication Complexity 和 Task Objective。</p><h4>Communication Complexity：</h4>* Initial Instruction：Oracle在一开始的时候给agent一句命令，告诉它去干嘛，后续不再涉及自然语言处理和理解，就是单纯的路径导航。* Oracle Guidance：agent在接收到初始命令之后，如果感到困惑，仍然无法完成目标任务，我们再告诉它应该怎么做，向左转之类的，Agent需要有后续继续理解自然语言的能力。* Dialogue：要求agent可随时对话交互，主动用自然语言去问我们问题。<p>目前，大多数的 Dataset 都集中在 Initial Instructions。这有几个原因了，一是创建 Dataset 的过程会比较简单，第二 Evaluation 也会相对比较简单，因为如果需要后续的 Oracle Guidance 和 Dialogue，agent 需要 Evaluate 的能力会更多就不止是是否到达终点或者找到目标物体，还有语言评估。目前 VLN 数据集非常少并且小，需求远远不够，属于数据稀缺领域（低资源模型，Low resource model）</p><h4>Task Objective：</h4>* Fine-grained：即开始给agent的指令是非常详细的，它只要按照给定的命令执行就可以，例如，先左转去到楼梯并上楼，然后右转去到厨房拿一个苹果。* Coarse-grained：这里不会给agent详细的指令，例如拿一个苹果给我。* Navigate and Object Interaction：为了完成任务，agent不仅仅需要Navigate，也需要做交互。例如我们要求agent去厨房里拿一些切开的苹果，但是它没有找到切开的苹果，只找到了完整的苹果，这时候，光靠Navigation是没有办法完成这个任务的，它需要拿一把刀，去执行和环境交互的动作，把苹果切开。<h4>评价指标：</h4>* Goal-oriented Metrics：面向目标，评估agent与目标的接近程度* Success Rate (SR)：最直观，衡量距离目标一定距离内完成任务的频率* Goal Progress(GP)：衡量距离目标的剩余距离的减少* Success weighted by Path Length(SPL)：平衡成功率和路径长度 <ul><li>Path-fidelity（准确性） Metrics：评估 agent 遵循指令路径的程度。有些任务要求代理不仅要找到目标位置，还要遵循特定的路径。</li><li>Coverage weighted by LS（CLS）：通过路径长度得分的加权覆盖率</li><li>Normalized Dynamic Time Warping (nDTW)：动态时间序列扭曲匹配，衡量两条路径之间的相似程度</li></ul><h4>Representation Learning：帮助Agent更好的对多模态信息进行理解</h4>* 1.Pretraining ：目前用的很多且有效，VILT、VILBERT* 2.Semantic（语义） Understanding：提取模态内部的规律或者模态之间的规律和特征加强信息。* 3.Graph Representation：感觉有点像SLAM，即时定位与地图构建，agent每走一步获取新的信息用图的方式来联系表达，图神经网络GNN* 4.Memory-augmented Model：记录历史信息并充分利用。因为VLN输入信息非常多，例如说过去的所有动作、对话交互，以及视觉内容都对以后的action有帮助，但是效率应该会降低，占用空间大，而且所有的信息可能反而存在噪音干扰信息误导agent。* 5.Auxiliary Tasks：解读过去的动作，评估导航的进度，预测下一步方向，评估轨迹和文本的一致性，这些额外的辅助训练信号帮助agent更好地获得了活动和环境中的语义信息。<h4>Strategy Learning：帮助agent进行action</h4>* 1.Reinforcement Learning:不像围棋，不好定义reward奖励某些行为或惩罚某些行为* 2.Exploration during Navigation：agent先随机探索，看完周围环境Agent再决定走哪里* 3.Navigation Planning：即提前计划并预测后面应该如何移动。* 4.Asking For Help：<h4>Data Centric Learning：</h4>是目前VLN非常有效的方法，因为目前VLN太过复杂，涉及的信息太多，vision、language和action这些信息都要求理解，同时信息还是动态的，然后输出一个动作。目前这种数据极度稀缺的情况下，Data-centric Learning发挥的作用非常大。<ul><li>1.Data Augmentation：可以根据已有的数据集生成路径和对应的自然语言描述，也可以先增强环境，当有更多的虚拟环境之后，再在其中建造更多的路径，例如 House3D，Matterport3D，谷歌街景等等</li><li>2.Curriculum Learning：训练策略，让模型先从容易的样本开始学习，并逐渐进阶到复杂的样本和知识。</li><li>3.Multitask Learning：同时学习多个任务，任务之间互相帮助，提高模型性能</li><li>4.Instruction Interpretation：换一种表达方式或者多次解释帮助 agent 更好理解指示命令。</li></ul><h4>4.Prior Exploration：预先让agent探索环境。</h4><h4>未来研究方向：</h4>Collaborative VLN：目前是一个，未来可以多个agent团队协助完成任务Simulation to Reality：正真落地应用，虚拟环境到现实agent性能会大幅下降，虚拟环境没有考虑到其他动态因素，例如人行走或物体移动，光照变化等Ethics & Privacy：agent自由探索会观察并存储导致敏感信息泄露或被滥用Multicultural VLN：VLN数据集使用美国城市房屋和谷歌街景，缺乏其他建筑。还有VLN语言<h4>目前局限性：</h4>没有结合外部知识（知识图谱），不能推理，人类拿碗筷，我们知道会去厨房找，但是agent不一定，且目前只是导航找到目标还没有交互动作，现在是问agent“给我拿个勺子”，新的研究可能会让agent如何“拿起勺子”。环境也缺乏多样性：大多数VLN数据由美国房屋组成，从未包括仓库或医院或者中式建筑、日式建，应用到其他场景，效果肯定就差。和传统的Visual-Language多模态任务相比，VLN更困难。首先，agents是在一个动态变化的环境当中，它不断地观察到新的环境并进行决策，过去观测到的环境信息和执行的动作对于agents下一步的行动是重要的，比如agents需要返回过去走过的一个位置。其次，agents所看到的视觉图像是和现有视觉模型训练的互联网图像不太一样，agent是一种embodied images会有更多样化的观测角度或者视野范围，这种视觉的差异使VLN更具挑战。最后，现有训练VLN的监督数据是比较有限的，这使得模型容易过拟合。]]></content>
      
      
      <categories>
          
          <category> 论文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多模态 </tag>
            
            <tag> Embodied AI </tag>
            
            <tag> VLN </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
